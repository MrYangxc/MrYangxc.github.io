<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java笔记之IO流</title>
    <link href="/2022/11/30/java%E7%AC%94%E8%AE%B0%E4%B9%8BIO%E6%B5%81/"/>
    <url>/2022/11/30/java%E7%AC%94%E8%AE%B0%E4%B9%8BIO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件时保存数据的地方，文件在程序中时以流的形式操作的。</p><p>流的定义：数据在数据源（文集N）和程序（内存）之间经历的路径。</p><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br>File file <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>file.createNewFile();<span class="hljs-comment">//创建文件</span><br><br><span class="hljs-comment">//方法二</span><br><span class="hljs-comment">//根据父目录文件+子路径构建</span><br><span class="hljs-type">File</span> <span class="hljs-variable">parentfile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;e:\\&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentFile, fileName);<br>file.createNewFile();<br><br><span class="hljs-comment">//方法三</span><br><span class="hljs-comment">//根据父目录+子路径构建</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentPath, fileName);<br></code></pre></td></tr></table></figure><h3 id="获取文件相关信息"><a href="#获取文件相关信息" class="headerlink" title="获取文件相关信息"></a>获取文件相关信息</h3><blockquote><p>getname()    &#x2F;&#x2F; 文件名字</p><p>getAbsolutePath()    &#x2F;&#x2F; 文件绝对路径 </p><p>getParent()    &#x2F;&#x2F; 文件父级目录 </p><p>length()    &#x2F;&#x2F; 文件大小(字节) </p><p>exists()    &#x2F;&#x2F; 文件是否存在 </p><p>isFile()    &#x2F;&#x2F; 是不是一个文件 </p><p>isDirectory()    &#x2F;&#x2F; “是不是一个目录 </p><p>mkdir()    &#x2F;&#x2F;创建一级目录</p><p>mkdirs()    &#x2F;&#x2F;创建多级目录</p><p>delete()    &#x2F;&#x2F;删除</p></blockquote><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ol><li>按操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件</li><li>按数据流的流向不同分为：输入流，输出流</li><li>按流的角色的不同分为：节点流，处理流&#x2F;包装流</li></ol><h2 id="InputStream字节输入流"><a href="#InputStream字节输入流" class="headerlink" title="InputStream字节输入流"></a>InputStream字节输入流</h2><ol><li>FileInputStream文件输入流</li><li>BufferedInputStream缓冲字节输入流</li><li>ObjectInputStream对象字节输入流</li></ol><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个字节读取，效率较低</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sfilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br>    <span class="hljs-keyword">while</span> ((readData) = fis.read() != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>)readData);  <span class="hljs-comment">//转成char显示</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fis.close();<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//byte读取文件，提高效率</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br><span class="hljs-keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>fileInputStream.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将数据写入文件中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//new FileOutputStream(filePath) 会覆盖原来内容</span><br>    fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath, <span class="hljs-literal">true</span>); <span class="hljs-comment">//会追加在文件后面</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    fileOutputStream.write(str.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fileOutputStream.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//拷贝文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">srcFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F:\\MrYang\\yxc.jpg&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">destFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F:\\MrYang\\yxc.jpg&quot;</span>;<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFilePath);<br>    fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(destFilePath);<br>    <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>        fileOutputStream.write(buf, <span class="hljs-number">0</span>, readLen);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;拷贝 ok~&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//关闭输入流和输出流，释放资源</span><br>        <span class="hljs-keyword">if</span> (fileInputStream != <span class="hljs-literal">null</span>) &#123;<br>            fileInputStream.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fileOutputStream != <span class="hljs-literal">null</span>) &#123;<br>            fileOutputStream.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FileReader和FileWriter"><a href="#FileReader和FileWriter" class="headerlink" title="FileReader和FileWriter"></a>FileReader和FileWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单个字符读取文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-keyword">while</span> ((data = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) data);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (fileReader != <span class="hljs-literal">null</span>) &#123;<br>            fileReader.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//字符数组读取文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">try</span> &#123;<br>    fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);<br>    <span class="hljs-keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, readLen));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (fileReader != <span class="hljs-literal">null</span>) &#123;<br>            fileReader.close();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//写入文件</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">char</span>[] chars = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    fileWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath);<br>    fileWriter.write(<span class="hljs-string">&quot;MrYang&quot;</span>);<br>&#125;  <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fileWriter.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ol><li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</li><li>处理流也叫包装流，是连接已存在的流（节点流或处理流）之上，为程序提供更强大的读写功能，如BufferedReader、BufferedWriter</li><li>节点流是底层流，直接更数据源详解</li><li>处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源项链</li></ol><h2 id="BufferedReader和BufferedWriter"><a href="#BufferedReader和BufferedWriter" class="headerlink" title="BufferedReader和BufferedWriter"></a>BufferedReader和BufferedWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.txt&quot;</span>;<br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath));<br>bufferedWriter.write(<span class="hljs-string">&quot;hello,MrYang&quot;</span>);<br>bufferedWriter.newLine();<span class="hljs-comment">//插入一个和系统相关的换行</span><br>bufferedWriter.write(<span class="hljs-string">&quot;hello2,MrYang&quot;</span>);<br>bufferedWriter.newLine();<br>bufferedWriter.write(<span class="hljs-string">&quot;hello3,MrYang&quot;</span>);<br>bufferedWriter.newLine();<br>bufferedWriter.close();<br><br><span class="hljs-comment">//拷贝（不要操作二进制文件（音频，视频，doc，pdf）可能造成损坏</span><br><span class="hljs-type">String</span> <span class="hljs-variable">srcFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">destFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang2.java&quot;</span>;<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>String line;<br><span class="hljs-keyword">try</span> &#123;<br>br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(srcFilePath));<br>bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(destFilePath));<br><span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>bw.write(line);<br>bw.newLine();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>) &#123;<br>br.close();<br>&#125;<br><span class="hljs-keyword">if</span>(bw != <span class="hljs-literal">null</span>) &#123;<br>bw.close();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ObjectInputStream和ObjectOutputStream"><a href="#ObjectInputStream和ObjectOutputStream" class="headerlink" title="ObjectInputStream和ObjectOutputStream"></a>ObjectInputStream和ObjectOutputStream</h2><p>将数据的数据类型或者对象保存在文件中，比如100保存的不是”100”而是int类型的100，并且能够从文件恢复，就是序列化和反序列化</p><p>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现这两个接口之一：Serializable（标记接口）、Externalizable（有方法需要实现，所以一般用前一个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写入</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\MrYang.dat&quot;</span>;<span class="hljs-comment">//.dat文件</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br>oos.writeInt(<span class="hljs-number">100</span>);<span class="hljs-comment">// int -&gt; Integer (实现了 Serializable)</span><br>oos.writeBoolean(<span class="hljs-literal">true</span>);<span class="hljs-comment">// boolean -&gt; Boolean (实现了 Serializable)</span><br>oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">// char -&gt; Character (实现了 Serializable)</span><br>oos.writeDouble(<span class="hljs-number">9.5</span>);<span class="hljs-comment">// double -&gt; Double (实现了 Serializable)</span><br>oos.writeUTF(<span class="hljs-string">&quot;中国&quot;</span>);<span class="hljs-comment">//String</span><br><span class="hljs-comment">//保存一个 dog 对象</span><br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;日本&quot;</span>, <span class="hljs-string">&quot;白色&quot;</span>));<br>oos.close();<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String city;<br>    String color;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String city, String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.city = city;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//读取</span><br> <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\MrYang.dat&quot;</span>));<br>        System.out.println(ois.readInt());<br>        System.out.println(ois.readBoolean());<br>        System.out.println(ois.readChar());<br>        System.out.println(ois.readDouble());<br>        System.out.println(ois.readUTF());<br>        System.out.println(ois.readObject());<br>        ois.close();<br><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>读写顺序要一致</li><li>要求序列化或反序列化对象需要实现Serializable</li><li>序列化的累中建议添加SerialVersionUID</li><li>序列化对象时，默认将里面所有属性都序列化，但除了static或transient修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol><h2 id="转换流InputStreamReader和OutputStreamWriter"><a href="#转换流InputStreamReader和OutputStreamWriter" class="headerlink" title="转换流InputStreamReader和OutputStreamWriter"></a>转换流InputStreamReader和OutputStreamWriter</h2><p>可以处理文件乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\a.txt&quot;</span>;<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> br.readLine();<br>System.out.println(<span class="hljs-string">&quot;读取内容=&quot;</span> + s);<br>br.close();<br><br><span class="hljs-comment">//写入</span><br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;d:\\a.txt&quot;</span>), <span class="hljs-string">&quot;gbk&quot;</span>);<br>osw.write(<span class="hljs-string">&quot;MrYang&quot;</span>);<br>osw.close();<br></code></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>专门用于读写配置文件的集合类</p><p>格式：</p><blockquote><p>键&#x3D;值</p><p>键&#x3D;值</p></blockquote><p>键值对不需要空格，值默认类型是String</p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><blockquote><p>load：家崽配置文件的键值到Properties对象</p><p>list：将数据显示到指定设备</p><p>getPreperty(key)：根据键获取值</p><p>setProperty(key,value)：设置键值对到Preperties对象</p><p>store：将Preperties中的键值对存储到配置文件</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>IO流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之多线程基础</title>
    <link href="/2022/11/29/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/11/29/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><ul><li>程序：为完成特定任务、用某种语言编写的一组指令的集合</li><li>进程：运行中的程序，比如打开一个电脑软件，就启动了一个进程，操作系统就会为该进程分配内存空间。进程是程序的一次执行过程，或者是正在运行的一个程序，是一个动态过程，有它自身的产生、存在和消亡</li><li>线程：由进程创建，是进程的一个实体，一个进程可以拥有多个线程，比如浏览器同时下载多个文件</li></ul><h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><ul><li>单线曾：同一个时刻，只允许执行一个线程</li><li>多线程：同一个时刻，可以执行多个线程，比如，浏览器同时下载多个文件</li><li>并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发</li><li>并行：同样给谁看，多个任务同时执行，多核cpu可以实现并行</li></ul><p>创建线程的两种方式：</p><ul><li>继承Thread类，重写run方法</li><li>实现Runnable接口，重写run方法</li></ul><p>由于java是单继承的，在某些情况下一个类可能已经继承了某个父类，这是再用继承Thread类方法创建线程就是不可能的，所以可以通过实现Runnable接口来创建线程</p><p>从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，Thread类本身就实现了Runnable接口。实现Runnable接口方式更加时候多个线程共享一个资源的清空，并且避免了单继承的限制</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><ol><li>当线程完成任务后，会自动退出</li><li>可以通过使用变量来控制run方法退出的方式停止线程，即<strong>通知方式</strong></li></ol><h2 id="线程常用方法："><a href="#线程常用方法：" class="headerlink" title="线程常用方法："></a>线程常用方法：</h2><blockquote><p><strong>设置线程名称，使之与参数name相同：</strong>    setName()</p><p><strong>返回该线程的名称：</strong>    getName()</p><p><strong>执行线程：</strong>    start()</p><p><strong>调用线程run方法：</strong>    run()</p><p><strong>更改线程的优先级：</strong>    setPriority()</p><p><strong>获取线程的优先级：</strong>    getPriority()</p><p><strong>使线程休眠：</strong>    sleep()</p><p><strong>终端线程：</strong>    interrupt()</p></blockquote><p><strong>另外两种方法：</strong></p><ol><li>yield()    线程的礼让，让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功</li><li>join()    插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有的子任务</li></ol><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ol><li>用户线程：也叫工作线程，当线程的任务执行完或通知的方式结束</li><li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束</li><li>常见的守护线程：垃圾回收机制</li><li>setDaemon(true)即设置成了守护线程</li></ol><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>在jdk中线程有六种状态</p><ol><li>new 尚未启动的线程处于此状态</li><li>runnable 在java虚拟机中执行的线程处于此状态</li><li>blocked 被阻塞等待监视器锁定的线程处于此状态</li><li>waiting 正在等待另一个线程执行特定动作的线程处于此状态</li><li>timed_waiting 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</li><li>terminated 已退出的线程处于此状态</li></ol><p>在有些书上面会说有七种，因为他们把runnable细化成ready和running</p><h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>在多线程编程种，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性</p><p>同步方法：用Synchronized修饰</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性，每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程来访问该对象，Synchronized来与对象的互斥锁联系。</p><p>同步方法（非静态）的锁可以是this，也可以是其他对象（要求是同一个对象）；同步方法（静态）的锁为当前类本身。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个线程都占用了对方的锁的资源，但不肯相让，导致了死锁。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p><strong>释放锁的操作：</strong></p><ol><li>当钱线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法种遇到break、return</li><li>当前线程在同步代码块、同步方法种出现了未处理的Error或Exception，导致异常结束</li><li>当前线程在同步代码块、同步方法种执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ol><p><strong>不会释放锁的操作：</strong></p><ol><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()0方法暂停当前线程的执行，不会释放锁</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该吸纳成不会释放锁</li></ol>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>多线程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之集合</title>
    <link href="/2022/11/28/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <url>/2022/11/28/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>保存多个数据使用数组可能会有很多不足的地方，所以引出集合，集合可以动态保存任意多个对象，使用方便。</p><p>集合分为Collection和Map两组，前一个是单列集合，后一个是双列集合。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection实现类有些是有序的（List），有些是无序的（Set）。</p><p>Collection接口没有直接的实现子类，是通过它的子接口List和Set来实现的。</p><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><blockquote><p><strong>添加：</strong>    add()    &#x2F;&#x2F;添加任意Object元素</p><p><strong>添加多个元素：</strong>    addAll()    &#x2F;&#x2F;可以添加一个list</p><p><strong>删除：</strong>    remove()    &#x2F;&#x2F;可以删除指定位置元素，也可以删除某个元素</p><p><strong>删除多个元素：</strong>    removeAll()    &#x2F;&#x2F;可以删除一个list</p><p><strong>查找：</strong>    contains()</p><p><strong>查找多个元素：</strong>    containsAll()    可以查找一个list</p><p><strong>大小：</strong>    size()</p><p><strong>判断是否为空：</strong>    isEmpty()</p><p><strong>清空：</strong>    clear()</p></blockquote><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>使用Iterator迭代器</p><blockquote><p><strong>判断下一个是否有元素：</strong>    hasNext()</p><p><strong>下移并返回元素：</strong>    next()</p><p><strong>删除当前指针所指的元素：</strong>    remove()</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p><strong>在id位置插入e元素：</strong>    add(int id, Object e)</p><p><strong>在id位置插入多个元素：</strong>    addAll(int id, Collection e)</p><p><strong>获取指定id位置的元素：</strong>    git(int id)</p><p><strong>e在集合中首次出现的位置：</strong>    indexOf(Object e)</p><p><strong>删除指定id位置的元素，并且返回：</strong>    Object remove(int id)</p><p><strong>设置指定id位置的元素为e：</strong>    set(int id, Object e)</p><p><strong>返回从begin到end位置的集合：</strong>    subList(int fromIndex, int toIndex)</p></blockquote><h3 id="List三种遍历方式："><a href="#List三种遍历方式：" class="headerlink" title="List三种遍历方式："></a>List三种遍历方式：</h3><ol><li>使用迭代器</li><li>使用增强for</li><li>使用普通for（用get）</li></ol><h3 id="ArrayList介绍"><a href="#ArrayList介绍" class="headerlink" title="ArrayList介绍"></a>ArrayList介绍</h3><p>可以加入null，并且能加入多个重复元素，ArrayList是由数组来实现数据存储的，基本等同于Vector，但是他是线程不安全的（虽然执行效率高），所以在多线程情况下，不使用ArrayList。</p><p>ArrayList维护了一个Object类型的数组elementData（transient修饰，表示该属性不会被序列化）。</p><p>创建ArrayList对象时，使用无参构造器，容量为0，第一次添加，扩容成10，之后每次扩容1.5倍。如果使用指定大小的构造器，之后每次扩容1.5倍。</p><h3 id="Vector介绍"><a href="#Vector介绍" class="headerlink" title="Vector介绍"></a>Vector介绍</h3><p>Vector也是维护了一个数组，但是是protected修饰的。Vector是线程同步即安全的，但是效率不太高，操作方法都带有synchronized修饰。</p><p>Vector与ArrayList扩容方面不同的是，Vector是2倍扩容。</p><h3 id="LinkedList介绍"><a href="#LinkedList介绍" class="headerlink" title="LinkedList介绍"></a>LinkedList介绍</h3><p>LinkedList实现了双向链表和双端队列的特点，线程不安全，不同步。</p><p><strong>如何选用ArrayList还是LinkedList：</strong></p><ol><li>如果查改比较多，选择ArrayList</li><li>如果增删比较多，选择LinkedList</li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set里面的元素是无序的，所以没有索引，且不允许重复元素。</p><p>和List一样，Set也是Collection的子接口，所以常用方法和Collection接口一样。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>本质是HashMap（可以通过源码验证），可以存放null，但只能一个null，HashSet不保证元素是有序的，取决于hash之后，再确定索引的结果。</p><p>添加一个元素时，先得到一个hash值，然后转换成索引值，再存储数据表table看这个索引位置是否已经存放元素，如果没有，直接加入，如果有，则用equals比较，遇到相同的就添加失败，不相同则添加在最后。</p><p><strong>扩容机制：</strong>定义一个HashSet，第一次添加时，table数组扩容到16，临界值是16<em>0.75 &#x3D; 12，如果table数组使用到了临界值12，就会扩容16**2 &#x3D; 32，新的临界值就是32</em>0.75 &#x3D; 24。</p><p>在java8中，如果一条链表的元素个数到达了TREEIFY_THRESHOLD（默认是8），并且table大小大于等于MIN_TREEIFY_CAPACITY（默认64），就会进行树化成红黑树，否则仍然采用数组扩容机制。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>和HashSet基本相同，只是TreeSet是排序的</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是HashSet的子类，LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map具有映射关系的数据：Key—Value，key不允许重复，但是value可以重复，key和value都可以为null。</p><h3 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h3><blockquote><p><strong>添加：</strong>    put(key, value)</p><p><strong>删除：</strong>    remove(key)</p><p><strong>查找：</strong>    get(key)</p><p><strong>个数：</strong>    size()</p><p><strong>判断是否为空：</strong>    isEmpty()</p><p><strong>清空：</strong>    clear()</p><p><strong>查找键是否存在：</strong>    containsKey(key)</p></blockquote><h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h3><p>第一种：通过keySet()来取出所有的key放入set中</p><p>第二种：通过values()把所有的value取出放出Collection中</p><p>第三种：通过EntrySet()来获取k-v</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HaspMap没有实现同步，因此线程不安全，方法没有做同步互斥的操作（没有synchronized修饰），扩容机制和HashSet一样。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>key是有序的，可以在需要排序Map的时候使用TreeMap，TreeMap也是线程不安全的。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>HashTable的key和value都不能为null，否则会抛出异常，其他的使用方法基本和HashMap一样。HashTable是线程安全的。</p><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties类继承自HashTable，并且实现了Map接口。使用特点和HashTable相似。</p><p>Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并惊醒读取和修改（xxx.properties文件通常作为配置文件）。</p><h2 id="总结集合的选择"><a href="#总结集合的选择" class="headerlink" title="总结集合的选择"></a>总结集合的选择</h2><p>1、先判断存储类型（单列还是双列）</p><p>对于单列（Collection）：</p><p>​    允许重复用List</p><blockquote><ol><li>增删多：LinkedList    （底层维护了一个双向链表）</li><li>查改多：ArrayList    （底层维护了一个Object类型的可变数组）</li><li>多线程安全时候，可以选用Vector</li></ol></blockquote><p>​    不允许重复用Set</p><blockquote><ol><li>无序：HashSet    （底层是HashMap，维护了一个哈希表，即数组+链表+红黑树）</li><li>排序：TreeSet</li><li>插入和取出顺序一致：LinkedHashset    （底层维护了一个数组+双向链表）</li></ol></blockquote><p>对于双列（Map）：</p><blockquote><ol><li>key无序：HashMap    （jdk7底层维护了数组+链表，jdk8底层维护了数组+链表+红黑树）</li><li>key排序：TreeMap</li><li>key插入和取出顺序一直：LinkedHashMap</li><li>读取文件：Properties</li></ol></blockquote><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是一个操作List、Set和Map等集合的工具，它提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。</p><blockquote><p><strong>反转：</strong>    reverse(List)</p><p><strong>随机排序：</strong>    shuffle(List)</p><p><strong>排序：</strong>    sort(List)</p><p><strong>交换：</strong>    swap(List, int, int)    &#x2F;&#x2F;可以加Comparator自定义</p><p><strong>最大值：</strong>    max(Collection)    &#x2F;&#x2F;可以加Comparator自定义</p><p><strong>最小值：</strong>    min(Collection)    &#x2F;&#x2F;可以加Comparator自定义</p><p><strong>元素出现次数：</strong>    frequency(Collection, Object)</p><p><strong>拷贝：</strong>    copy(List a, List b)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之String</title>
    <link href="/2022/11/27/java%E7%AC%94%E8%AE%B0%E4%B9%8BString/"/>
    <url>/2022/11/27/java%E7%AC%94%E8%AE%B0%E4%B9%8BString/</url>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String的字符使用Unicode字符编码，一个字符占两个字节。</p><p>创建String常用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接赋值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Mr.Yang&quot;</span>;<br><span class="hljs-comment">//调用构造器</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String original);<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a);<br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> count);<br></code></pre></td></tr></table></figure><p><strong>直接赋值：</strong>先从常量池查看是否有“MrYang”数据空间，如果有，直接指向；如果没有，则创建，然后指向，<strong>最终指向的时常量池中的空间地址</strong>。</p><p><strong>调用构造器：</strong>先在堆中创建空间，里面维护了value的属性，然后指向常量池里的MrYang空间。如果没有“MrYang”，则重新创建，如果有，则直接通过value指向。<strong>最终指向的时堆中的空间地址</strong>。</p><blockquote><p><strong>重要规则：</strong>String a &#x3D; “ab” + “cd”，是常量相加，在常量池里处理；String s &#x3D; a + b，变量相加，在堆中处理</p></blockquote><p>注意：但是String类是保存字符串常量的，每次更新都需要重新开辟空间，效率较低，因此还有StringBuilder和StringBuffer来增强String的功能</p><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>表示可变的字符序列，可以对字符串内容进行增删，StringBuffer是一个容器。</p><p><strong>StringBuffer</strong>字符内容都是存在char[] value中，但是这个value没有final修饰，所以可以进行变化，不用每次都创建新对象。</p><h2 id="String和StringBuffer相互转换"><a href="#String和StringBuffer相互转换" class="headerlink" title="String和StringBuffer相互转换"></a>String和StringBuffer相互转换</h2><p><strong>String转换成StringBuffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MrYang&quot;</span>;<br><br><span class="hljs-comment">//方法一</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(s);<br><br><span class="hljs-comment">//方法二</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>str = str.append(s);<br></code></pre></td></tr></table></figure><p><strong>StringBuffer转换成String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;MrYang&quot;</span>);<br><br><span class="hljs-comment">//方法一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> str.toString();<br><br><span class="hljs-comment">//方法二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);<br></code></pre></td></tr></table></figure><h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2><blockquote><p><strong>增：</strong>    append()</p><p><strong>删：</strong>    delete（begin, end)</p><p><strong>改：</strong>    replace(begin, end, “s”) （长度可以不相同）</p><p><strong>查：</strong>    int id &#x3D; str.indexOf(“abc”)</p><p><strong>插：</strong>    insert(begin, “abc”)</p></blockquote><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>一个可变的字符序列，此类提供一个与Stringbuffer兼容的API，但不保证同步（多线程时不安全）。该类被设计用作StringBuffer的简易替换，用在字符串缓冲区被<strong>单个线程</strong>使用的时候。单线程时，推荐使用，会比StringBuffer快。</p><h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><ul><li>如果字符串存在大量的修改操作，并且在单线程的情况，使用StringBuilder</li><li>如果字符串存在大量的修改操作，并且在多线程的情况，使用StringBuffer</li><li>如果字符串很少修改，且被多个对象引用，使用String，比如配置信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>String</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之异常</title>
    <link href="/2022/11/26/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/11/26/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><p>执行过程中所发生的异常事件可分为两大类：</p><ol><li>Error：Java虚拟机无法解决的严重问题。比如JVM系统内部错误、资源耗尽等严重情况。（Error是严重错误，会导致程序崩溃）</li><li>Exception：其他因为编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如空指针访问，试图杜旭不存在的文件，网络连接中断等等。（Exception可以分为两大类：运行异常和编译异常）</li></ol><h2 id="一般性异常介绍"><a href="#一般性异常介绍" class="headerlink" title="一般性异常介绍"></a>一般性异常介绍</h2><p>对于运行异常，可以不作处理，因为这类异常很普遍，若全部处理可能对程序的可读性和运行效率产生影响。</p><p>对于编译异常，是要求必须处理的异常。</p><h3 id="常见的运行异常"><a href="#常见的运行异常" class="headerlink" title="常见的运行异常"></a>常见的运行异常</h3><p>常见的运行异常包括五类：</p><ol><li>NullPointerException 空指针异常</li><li>ArithmeticException 数学运算异常</li><li>ArrayIndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 类型转换异常</li><li>NumberFormatException 数字格式不正确异常[]</li></ol><h3 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h3><ol><li>SQLException 操作数据库时，查询表可能发生异常</li><li>IOException 操作文件时，发生的异常</li><li>FileNotFoundException 当操作一个不存在的文件时，发生异常</li><li>EOFException 加载类，而该类不存在时，异常</li><li>IllegalArguementException 参数异常</li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理方式：</p><p><strong>1、try-catch-finally</strong></p><p><strong>可以有多个catch语句，对于不同的业务进行处理，要求子类异常在父类异常前面，也可以没有catch语句，出现异常直接执行finally，然后程序崩溃或者退出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//try-catch-finally</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//可能出现异常的代码</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>    <span class="hljs-comment">//捕获到异常，异常发生时，将异常封装成e，传递给catch，程序员自己处理</span><br>    <span class="hljs-comment">//如果没有发生异常，catch代码不执行</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//不管是否发生异常，始终执行finally</span><br>    <span class="hljs-comment">//通常，将释放资源这类的代码放在finally</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、throws</strong></p><p><strong>写在方法声明中，如果可能发生异常，但是不能确定如何处理这类异常，可以通过throws让该方法的调用者负责处理。</strong></p><p>注意：</p><ul><li>对于运行异常，程序中如果没有明确处理，默认用throws方法处理。</li><li>子类重写父类方法时，子类抛出的异常类型要么和父类抛出的异常一致，要么时父类抛出异常的子类。</li><li>在向上throws的过程中，如果遇到了try-chatch-finally，相当于处理异常，就可以不必继续throws。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eradFile</span><span class="hljs-params">(String file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d:\\a.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、自定义异常</strong></p><p><strong>当程序中出现了某些错误，但是系统并没有给出对应的描述，此时可以自己设计异常类。</strong></p><p>自定义异常继承Exception（属于编译异常），继承RuntiemeException（属于运行异常）（一般继承RuntimeException）</p><h3 id="throw和throws区别"><a href="#throw和throws区别" class="headerlink" title="throw和throws区别"></a>throw和throws区别</h3><blockquote><p>throws  异常处理的一种方式，出现在方法声明处，后面接异常类型</p><p>throw  手动生成异常对象的关键字，出现在方法体中，后面接异常对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之内部类</title>
    <link href="/2022/11/25/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/11/25/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><strong>类的五大成员</strong>（面试经常提问）：属性、方法、构造器、代码块、内部类</p><p>内部类最大的特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系，内部类的分类：</p><p><strong>定义在外部类局部位置上（比如方法内）</strong>：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名）</li></ol><p><strong>定义在外部类成员位置上</strong>：</p><ol><li>成员内部类（无static修饰）</li><li>静态内部类（有static修饰）</li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><blockquote><p>可以直接访问外部类的所有成员，包括私有的。不能添加访问修饰符，但是可以用final修饰。</p><p>作用域：仅仅在定义它的方法或者代码块中。</p><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果像访问外部类的成员，</p><p>可以通过外部类名.this.成员去访问。</p></blockquote><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>好处是，可以当作实参直接传递，使得代码简洁高效</p><h3 id="基于接口"><a href="#基于接口" class="headerlink" title="基于接口"></a>基于接口</h3><blockquote><p>当我们定义个一个接口之后，可能需要写多个类来实现接口，并创建对象，但是使用匿名内部类</p><p>只需要写一次类，并创建对象。匿名内部类使用一次就会被销毁。</p><p>匿名内部类是有名字的，计算机底层会给他起名为外部类+$1。</p></blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Outer</span> <span class="hljs-variable">iner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>() &#123;<br>    <span class="hljs-comment">//重写方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="基于类"><a href="#基于类" class="headerlink" title="基于类"></a>基于类</h3><p>效果同基于接口的</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-type">Outer</span> <span class="hljs-variable">iner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(参数列表) &#123;<br>    <span class="hljs-comment">//重写方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;;<br>iner.solve();<br><br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(参数列表) &#123;<br>    <span class="hljs-comment">//重写方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;.solve();<br></code></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><blockquote><p>定义在外部类的成员位置，没有static修饰。</p><p>可以调用外部类的所有成员，方法。如果外部类方法要调用内部类，可以先创建一个对象</p><p>如果其他的类要调用的话，有两种方法，一种可以类似Outer.iner item &#x3D; Outer.new iner();</p><p>另一种如果内部类为私有成员，可以用一个public函数返回一个内部类。</p></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>定义在外部类的成员位置，有static修饰。</p><p>不能直接访问非静态成员</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java笔记</category>
      
      <category>内部类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用方法</title>
    <link href="/2022/11/24/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/11/24/git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><p>这是建立在git与github建立连接基础上使用的指令，建立连接的指令跳转到下一个目录</p><blockquote><p><strong>git status</strong>    查看仓库状态</p></blockquote><blockquote><p><strong>git init</strong>    初始化仓库</p></blockquote><blockquote><p><strong>git add file.suffix</strong>    将file文件添加到临时缓存区</p></blockquote><blockquote><p><strong>git commit -m “file”</strong>    将file文件添加到Git仓库</p></blockquote><blockquote><p><strong>git log</strong>    显示提交日志</p></blockquote><blockquote><p><strong>git branch</strong>    查看Git仓库分支状态</p></blockquote><blockquote><p><strong>git branch a</strong>    建立一个名为a的分支</p></blockquote><blockquote><p><strong>git checkout a</strong>    切换到a分支</p></blockquote><blockquote><p><strong>git check out -b a</strong>    直接切换到新建立的a分支</p></blockquote><blockquote><p> <strong>git merge a</strong>    将a分支合并到当前所在的分支</p></blockquote><blockquote><p><strong>git branch -d a</strong>    删除a分支</p></blockquote><blockquote><p><strong>git branch -D a</strong>    如果删除不了，可以大写D强行删除</p></blockquote><blockquote><p><strong>git tag</strong>    查看当前标签记录</p></blockquote><blockquote><p><strong>git tag a</strong>    为当前分支添加一个标签</p></blockquote><blockquote><p><strong>git checkout a</strong>    切换到当前标签下的代码状态</p></blockquote><blockquote><p><strong>git clone http</strong>    克隆想要的项目到当前Git的文件夹下</p></blockquote><h1 id="Git与github建立连接"><a href="#Git与github建立连接" class="headerlink" title="Git与github建立连接"></a>Git与github建立连接</h1><blockquote><p> <strong>ssh-keygen -t rsa</strong>    通过RSA算法生成密钥，将id_rsa.pub文件的内容添加到github上</p></blockquote><blockquote><p> <strong>ssh -T <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;</a></strong>    测试密钥是否与公钥进行连接</p></blockquote><blockquote><p><strong>git push origin master(main)</strong>    将本地文件推送到仓库中</p></blockquote><blockquote><p><strong>git pull origin master(main)</strong>    将仓库文件获取到本地中</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>git操作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记之接口</title>
    <link href="/2022/11/24/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/11/24/java%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>​       <strong>接口我认为就是给出一些没有实现的方法（类似于抽象类），将它们封装到一起，等到某个类要使用的时候，再进行方法重写</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> inplements A &#123;<br>    <span class="hljs-comment">//自己的属性</span><br>    <span class="hljs-comment">//自己的方法</span><br>    <span class="hljs-comment">//必须覆盖的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><ol><li>在接口中，抽象方法可以省略abstract关键字</li><li>在jdk8之前，接口不能有具体方法实现，但是jdk8之后，可以有默认实现方法（通过default实现），以及静态方法（通过static实现）</li><li>接口不能被实例化（类似抽象类）</li><li>一个类可以同时实现多个接口（与继承不同）</li><li>接口中的属性只能是final的，而且是public static final修饰符</li><li>接口也具有多态性</li></ol>]]></content>
    
    
    <categories>
      
      <category>java学习笔记</category>
      
      <category>接口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java学习笔记</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客数论刷题之旅1~10题</title>
    <link href="/2022/11/01/%E7%89%9B%E5%AE%A2%E6%95%B0%E8%AE%BA%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%851-10%E9%A2%98/"/>
    <url>/2022/11/01/%E7%89%9B%E5%AE%A2%E6%95%B0%E8%AE%BA%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%851-10%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="第一题-约数个数的和"><a href="#第一题-约数个数的和" class="headerlink" title="第一题 约数个数的和"></a><a href="(https://ac.nowcoder.com/acm/problem/14682)">第一题 约数个数的和</a></h2><p><strong>题目描述：</strong> 给个n，求1到n的所有数的约数个数的和</p><p><strong>解题过程：</strong>开始的想法是遍历1到n的然后用求约数的公式（a的约数个数为(1+c1)(1+c2)…)但是n最大1e8会T，后来换了想法遍历约数1到n，则每个约数出现的个数为n&#x2F;i。</p><p><strong>心得：</strong>遍历的时候可以遍历可能出现更多的量，比如这题所求的数每个只出现一次，但是同样1到n范围的约数，每个会出现多次。</p><h2 id="第二题-集合中的质数"><a href="#第二题-集合中的质数" class="headerlink" title="第二题 集合中的质数"></a><a href="https://ac.nowcoder.com/acm/problem/14686">第二题 集合中的质数</a></h2><p><strong>题目描述：</strong>给出一个集合和一个数m，集合里面有n个质数，请你求出从 1 到 m 的所有数中，至少能被集合中的一个数整除的数的个数。</p><p><strong>解题过程：</strong>发现n的数据范围只有20，又发现题目里出现至少被一个整除，于是想到了容斥原理。这题利用容斥原理能快速ac。</p><h3 id="珂朵莉的数论题"><a href="#珂朵莉的数论题" class="headerlink" title=" 珂朵莉的数论题 "></a><a href="https://ac.nowcoder.com/acm/problem/14832"> 珂朵莉的数论题 </a></h3><p><strong>题目描述：</strong>珂朵莉想求：第x小的正整数v使得其最小的质因数为质数y，即正好有x-1个[1,v-1]之内的正整数满足其最小的质因数为质数y，若答案超过1000000000则输出0。</p><p><strong>解题过程：</strong>这题一开始没有头绪，是去搜的题解，csdn搜的题解是判断y的大小，y较小用容斥加二分，y较大则是直接线性筛。但是后来发现了个更巧妙的方法，方法如下：</p><p>本题可以理解成y*k，k包含比y大的数，k从y开始每次加2，因为y &gt; 2之后所有的质因数都是奇数，对于每一个k，定义一个j从3开始到y，如果k能整除j，说明有比y小的质因数，则这个k不成立，如果j大于等于y，说明这个k成立，x–。这个方法通过从y开始逐渐增大，达到排序的效果，且确保了复杂度在o(n)。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国剩余定理</title>
    <link href="/2022/10/29/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <url>/2022/10/29/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>中国剩余定理是用来求解一堆线性同余方程组的通解的算法。</p><p>例如： <em>x</em> ≡ <em>a</em>i (<em>m</em>o<em>d</em>  <em>m</em>i) i &#x3D; 1,2,3…  其中，<em>m</em>1，<em>m</em>2，… ，<em>m</em>n两两互质。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-type">int</span> n;<br>ll a[<span class="hljs-number">30</span>],m[<span class="hljs-number">30</span>],M = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">算法步骤:</span><br><span class="hljs-comment">计算模数积，然后遍历每个方程，让答案累加a[i]*M/m[i]*inv(M/m[i],m[i]);</span><br><span class="hljs-comment">其中inv(a,b)表示a在modb意义下的逆元。</span><br><span class="hljs-comment">注意，中国剩余定理必须要满足模数两两互质。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; T <span class="hljs-title">gcd</span><span class="hljs-params">(T a, T b)</span></span>&#123;<br><span class="hljs-keyword">return</span> !b?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!b)&#123;<br>x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>y -= a/b*x;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a, ll b)</span></span>&#123;<br>ll x,y;<br><span class="hljs-built_in">exgcd</span>(a,b,x,y);<br><span class="hljs-keyword">return</span> (x%b+b)%b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m[i],&amp;a[i]);<br>M *= m[i];<br>&#125;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>ans = (ans + a[i]*M/m[i]*<span class="hljs-built_in">inv</span>(M/m[i],m[i]))%M;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans%M + M)%M);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><p>于中国剩余定理相比，模数不再两两互质，所以同余方程组可能无解。</p><p>其算法通过n-1次循环将n隔方程合并为一个方程，最后得到整个方程组的通解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a,ll b,ll mod)</span></span>&#123;<span class="hljs-comment">//O(1)取模快速乘，不会爆long long</span><br><span class="hljs-keyword">return</span> (a*b-(ll)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)a/mod*b)*mod+mod)%mod;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!b)&#123;<br>x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br>ll d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>y -= a/b*x;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>ll a1,m1;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m1,&amp;a1);<br><span class="hljs-type">bool</span> ok = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>ll a2,m2,k1,k2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m2,&amp;a2);<br>ll d = <span class="hljs-built_in">exgcd</span>(m1,m2,k1,k2);<br><span class="hljs-keyword">if</span>((a2-a1)%d) ok = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>k1 = <span class="hljs-built_in">mul</span>(k1,(a2-a1)/d,m2/d);<span class="hljs-comment">//这个地方必须要用取模快速乘</span><br>a1 = a1+k1*m1;<br>m1 = <span class="hljs-built_in">abs</span>(m1/d*m2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ok)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(a1%m1+m1)%m1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MR和PR算法</title>
    <link href="/2022/09/15/MR%E5%92%8CPR%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/15/MR%E5%92%8CPR%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MillerRabin大素数测试算法"><a href="#MillerRabin大素数测试算法" class="headerlink" title="MillerRabin大素数测试算法"></a>MillerRabin大素数测试算法</h1><p>算法原理：费马定理，二次检测定理</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">mod_mul</span><span class="hljs-params">(ll a, ll b, ll mod)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)<br>            res = (res + a) % mod;<br>        a = (a + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function">ll <span class="hljs-title">mod_pow</span><span class="hljs-params">(ll a, ll n, ll mod)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            res = <span class="hljs-built_in">mod_mul</span>(res, a, mod);<br>        a = <span class="hljs-built_in">mod_mul</span>(a, a, mod);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-comment">// Miller-Rabin随机算法检测n是否为素数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">millerrabin</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">46856248255981ll</span> || n &lt; <span class="hljs-number">2</span> || !(n &amp; <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    ll m = n - <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!(m &amp; <span class="hljs-number">1</span>))<br>    &#123;<br>        k++;<br>        m &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++)  <span class="hljs-comment">// 20为Miller-Rabin测试的迭代次数</span><br>    &#123;<br>        ll a = <span class="hljs-built_in">rand</span>() % (n - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        ll x = <span class="hljs-built_in">mod_pow</span>(a, m, n);<br>        ll y;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++)<br>        &#123;<br>            y = <span class="hljs-built_in">mod_mul</span>(x, x, n);<br>            <span class="hljs-keyword">if</span> (y == <span class="hljs-number">1</span> &amp;&amp; x != <span class="hljs-number">1</span> &amp;&amp; x != n - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            x = y;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (y != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Pollard-Rho算法"><a href="#Pollard-Rho算法" class="headerlink" title="Pollard-Rho算法"></a>Pollard-Rho算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//要用到__int128</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">f</span><span class="hljs-params">(ll x,ll c,ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((lll)x*x+c)%n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">pollardrho</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll s=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>,c=<span class="hljs-number">1ll</span>*<span class="hljs-built_in">rand</span>()%(x<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> stp=<span class="hljs-number">0</span>,goal=<span class="hljs-number">1</span>;<br>    ll val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(goal=<span class="hljs-number">1</span>;;goal&lt;&lt;=<span class="hljs-number">1</span>,s=t,val=<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(stp=<span class="hljs-number">1</span>;stp&lt;=goal;++stp)<br>        &#123;<br>            t=<span class="hljs-built_in">f</span>(t,c,x);<br>            val=(lll)val*<span class="hljs-built_in">abs</span>(t-s)%x;<br>            <span class="hljs-keyword">if</span>((stp%<span class="hljs-number">127</span>)==<span class="hljs-number">0</span>)<br>            &#123;<br>                ll d=__gcd(val,x);<br>                <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> d;<br>            &#125;<br>        &#125;<br>        ll d=__gcd(val,x);<br>        <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>质数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tarjan</title>
    <link href="/2022/07/29/tarjan/"/>
    <url>/2022/07/29/tarjan/</url>
    
    <content type="html"><![CDATA[<h1 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>     <span class="hljs-type">int</span> v,next;<br> &#125;edge[<span class="hljs-number">1001</span>];<br>  <span class="hljs-type">int</span> DFN[<span class="hljs-number">1001</span>],LOW[<span class="hljs-number">1001</span>];<br> <span class="hljs-type">int</span> stack[<span class="hljs-number">1001</span>],heads[<span class="hljs-number">1001</span>],visit[<span class="hljs-number">1001</span>],cnt,tot,index;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>     edge[++cnt].next=heads[x];<br>     edge[cnt].v = y;<br>     heads[x]=cnt;<br>    <span class="hljs-keyword">return</span> ;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//代表第几个点在处理。递归的是点。</span></span><br><span class="hljs-function"> </span>&#123;<br>     DFN[x]=LOW[x]=++tot;<span class="hljs-comment">// 新进点的初始化。</span><br>     stack[++index]=x;<span class="hljs-comment">//进站</span><br>     visit[x]=<span class="hljs-number">1</span>;<span class="hljs-comment">//表示在栈里</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=heads[x];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<br>     &#123;<br>         <span class="hljs-keyword">if</span>(!DFN[edge[i].v]) &#123;<span class="hljs-comment">//如果没访问过</span><br>            <span class="hljs-built_in">tarjan</span>(edge[i].v);<span class="hljs-comment">//往下进行延伸，开始递归</span><br>             LOW[x]=<span class="hljs-built_in">min</span>(LOW[x],LOW[edge[i].v]);<span class="hljs-comment">//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visit[edge[i].v ])&#123;  <span class="hljs-comment">//如果访问过，并且还在栈里。</span><br>             LOW[x]=<span class="hljs-built_in">min</span>(LOW[x],DFN[edge[i].v]);<span class="hljs-comment">//比较谁是谁的儿子／父亲。就是链接对应关系</span><br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">if</span>(LOW[x]==DFN[x]) <span class="hljs-comment">//发现是整个强连通分量子树里的最小根。</span><br>    &#123;<br>         <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack[index]);<br>             visit[stack[index]]=<span class="hljs-number">0</span>;<br>             index--;<br>         &#125;<span class="hljs-keyword">while</span>(x!=stack[index+<span class="hljs-number">1</span>]);<span class="hljs-comment">//出栈，并且输出。</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> ;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">memset</span>(heads,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(heads));<br>     <span class="hljs-type">int</span> n,m;<br>     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> x,y;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>     &#123;<br>         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        <span class="hljs-built_in">add</span>(x,y);<br>     &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>         <span class="hljs-keyword">if</span>(!DFN[i])  <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-comment">//当这个点没有访问过，就从此点开始。防止图没走完</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ac自动机</title>
    <link href="/2022/07/16/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2022/07/16/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trie</span> &#123;<br><span class="hljs-type">int</span> ch[<span class="hljs-number">27</span>];<br><span class="hljs-type">int</span> fail, ed;<br>&#125;t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br><span class="hljs-type">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!t[p].ch[u]) t[p].ch[u] = ++ idx;<br>p = t[p].ch[u];<br>&#125;<br>t[p].ed ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_fail</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>].ch[i]) &#123;<br>t[t[<span class="hljs-number">0</span>].ch[i]].fail = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(t[<span class="hljs-number">0</span>].ch[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (t[p].ch[i]) &#123;<br>t[t[p].ch[i]].fail = t[t[p].fail].ch[i];<br>q.<span class="hljs-built_in">push</span>(t[p].ch[i]);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>t[p].ch[i] = t[t[p].fail].ch[i];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>p = t[p].ch[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = p; u &amp;&amp; t[u].ed != <span class="hljs-number">-1</span>; u = t[u].fail) &#123;<br>ans += t[u].ed;<br>t[u].ed = <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manacher算法</title>
    <link href="/2022/07/12/manacher%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/12/manacher%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">3e7</span>;<br><span class="hljs-type">char</span> s[maxn], t[maxn];<br><span class="hljs-type">int</span> p[maxn];<br><br><span class="hljs-comment">//将字符串扩展</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>t[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;&amp;&#x27;</span>;<br><span class="hljs-type">int</span> l = <span class="hljs-built_in">strlen</span>(s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i ++ ) &#123;<br>t[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>t[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>] = s[i];<br>&#125;<br>t[l*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>t[l*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> maxx = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (maxx &gt; i) p[i] = <span class="hljs-built_in">min</span>(p[pos*<span class="hljs-number">2</span>-i], maxx - i);<br><span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (t[i-p[i]] == t[i+p[i]]) p[i] ++;<br><span class="hljs-keyword">if</span> (i + p[i] &gt; maxx) &#123;<br>maxx = i + p[i];<br>pos = i;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(ans,p[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/07/08/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/08/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;&quot;</span>, p = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = p.<span class="hljs-built_in">length</span>();<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br>p = <span class="hljs-string">&quot; &quot;</span> + p;<br><span class="hljs-comment">//求next</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br><span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br><span class="hljs-keyword">if</span> (p[i] == p[j+<span class="hljs-number">1</span>]) j ++;<br>ne[i] = j;<br>&#125; <br><span class="hljs-comment">//模式串匹配 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) &#123;<br><span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br><span class="hljs-keyword">if</span> (s[i] == p[j+<span class="hljs-number">1</span>]) j ++;<br><span class="hljs-keyword">if</span> (j == m) &#123;<br>j = ne[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/07/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/07/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><h2 id="自然溢出"><a href="#自然溢出" class="headerlink" title="自然溢出"></a>自然溢出</h2><p>最快的，也是安全系数比较低的哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">131</span>;<br>ull a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function">ull <span class="hljs-title">hsh</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = ans * base + (ull)s[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单哈希"><a href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">131</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hsh</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base + (ull)s[i]) % mod;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base1 = <span class="hljs-number">131</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base2 = <span class="hljs-number">29</span>;<br><span class="hljs-type">const</span> ull mod1 = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> ull mod2 = <span class="hljs-number">1e9</span> + <span class="hljs-number">9</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> x, y;<br>&#125;a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">hsh1</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base1 + (ull)s[i]) % mod1;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">hsh2</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base2 + (ull)s[i]) % mod2;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022暑假训练内容</title>
    <link href="/2022/07/07/2022%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E5%86%85%E5%AE%B9/"/>
    <url>/2022/07/07/2022%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>本篇博客主要记录2022年暑假训练的内容，其中包含自己学习的算法，刷的题目，杭电多校被虐的题目，以及对于一个暑假学习的心得体会                                                                                                                                                                   </p><h2 id="7-7自主学习"><a href="#7-7自主学习" class="headerlink" title="7.7自主学习"></a>7.7自主学习</h2><ul><li>组合数三种方法</li><li>2021 Jiangsu Collegiate Programming Contest</li></ul><h3 id="组合数三种方法"><a href="#组合数三种方法" class="headerlink" title="组合数三种方法"></a>组合数三种方法</h3><ol><li>递推法求组合数</li><li>预处理逆元求组合数</li><li>Lucas定理求组合数</li></ol><h3 id="2021-Jiangsu-Collegiate-Programming-Contest"><a href="#2021-Jiangsu-Collegiate-Programming-Contest" class="headerlink" title="2021 Jiangsu Collegiate Programming Contest"></a>2021 Jiangsu Collegiate Programming Contest</h3><h4 id="A-Spring-Couplets"><a href="#A-Spring-Couplets" class="headerlink" title="A. Spring Couplets"></a><a href="(https://codeforces.com/gym/103495/problem/A)">A. Spring Couplets</a></h4><blockquote><p>给一副对联，判断是否满足平仄规则</p><p>关键词：模拟</p></blockquote><p>这里我一开始没注意到每个字都要对应平仄相反，这道题直接模拟一遍即可</p><h4 id="C-Magical-Rearrangement"><a href="#C-Magical-Rearrangement" class="headerlink" title="C. Magical Rearrangement"></a><a href="(https://codeforces.com/gym/103495/problem/C)">C. Magical Rearrangement</a></h4><blockquote><p>使用给定的数字集合构造一个尽可能小的相邻数字不同的数，不允许有前导零（单独一个 0 不算前导零）</p><p>关键词：贪心，分类讨论 </p></blockquote><p>这也是一道考思维的题目，其中分几类讨论即可</p><h4 id="I-Fake-Walsh-Transform"><a href="#I-Fake-Walsh-Transform" class="headerlink" title="I. Fake Walsh Transform"></a><a href="(https://codeforces.com/gym/103495/problem/I)">I. Fake Walsh Transform</a></h4><blockquote><p>用 0 到 2^m - 1 范围内（包括两端）尽可能多的数的异或和表示 n，求最多可以用多少个数来表示 </p><p>关键词：分类讨论  </p></blockquote><p>从0到2 ^ m - 1所有数异或之和为0（m &gt; 1），所以只要特判m &#x3D; 1 的情况，其他时候不取 n 就行了</p><h4 id="J-Anti-merge"><a href="#J-Anti-merge" class="headerlink" title="J. Anti-merge"></a><a href="(https://codeforces.com/gym/103495/problem/J)">J. Anti-merge</a></h4><blockquote><p>对于一个数表，对于相同的单元格进行合并，优先合并相同内容的行，再合并高度相同且行内容相同的列。现在想让所有的单元格都不会合并，方法是添加一些标记。问需要至少要给多少单元格添加标记，至少添加多少种标记</p><p>关键词：BFS，黑白染色   </p></blockquote><p>这题只需要对整个图进行bfs，然后选取每个连通块染色相对少的数量就好了</p><h4 id="K-Longest-Continuous-1"><a href="#K-Longest-Continuous-1" class="headerlink" title="K. Longest Continuous 1"></a><a href="https://codeforces.com/gym/103495/problem/K">K. Longest Continuous 1</a></h4><blockquote><p>将 0, 1, 2, . . . 不含前导 0 的二进制形式依次拼接成一个字符串，求长度为 k 的前缀中最长连续 1 的长度 </p><p>关键词：二分，打表 </p></blockquote><p>这题可以通过找规律验证发现每次加上2 ^ m - 1 时会有最大前导 0，所以可以打表寻找那个临界长度，然后每次二分查找或者线性查找即可</p><h2 id="7-8自主学习"><a href="#7-8自主学习" class="headerlink" title="7.8自主学习"></a>7.8自主学习</h2><blockquote><p>2021 Jiangsu Collegiate Programming Contest</p><p>字符串哈希三种方法</p><p>kmp算法</p></blockquote><h3 id="2021-Jiangsu-Collegiate-Programming-Contest-1"><a href="#2021-Jiangsu-Collegiate-Programming-Contest-1" class="headerlink" title="2021 Jiangsu Collegiate Programming Contest"></a>2021 Jiangsu Collegiate Programming Contest</h3><h4 id="D-Pattern-Lock"><a href="#D-Pattern-Lock" class="headerlink" title="D. Pattern Lock"></a><a href="https://codeforces.com/gym/103495/problem/D">D. Pattern Lock</a></h4><blockquote><p>n 行 m 列的点阵图，用一条折线经过所有的点各一次，要求每条线段不经过除端点外的其他点，且形成的角都是锐角 </p><p>关键词：构造 </p></blockquote><p>这题可以分行列的奇偶性来讨论，对于偶数可以有固定的规律进行连接点，奇数则进行特殊处理</p><h3 id="字符串哈希三种方法"><a href="#字符串哈希三种方法" class="headerlink" title="字符串哈希三种方法"></a>字符串哈希三种方法</h3><ol><li>自然溢出hash</li><li>单hash</li><li>双hash</li></ol><h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><h2 id="7-12自主学习"><a href="#7-12自主学习" class="headerlink" title="7.12自主学习"></a>7.12自主学习</h2><blockquote><p>洛谷题单字符串（kmp）</p><p>Manacher算法</p><p> Codeforces Round #806 (Div. 4) </p></blockquote><h3 id="洛谷题单字符串（kmp）"><a href="#洛谷题单字符串（kmp）" class="headerlink" title="洛谷题单字符串（kmp）"></a>洛谷题单字符串（kmp）</h3><h4 id="P4391-BOI2009-Radio-Transmission-无线传输"><a href="#P4391-BOI2009-Radio-Transmission-无线传输" class="headerlink" title="P4391 [BOI2009]Radio Transmission 无线传输"></a><a href="https://www.luogu.com.cn/problem/P4391">P4391 [BOI2009]Radio Transmission 无线传输</a></h4><p>这题为了找最小循环字串，可以引用kmp中求niext数组的思想， 通过ne[n]，找到最短后缀，然后n - ne[n]得出结果</p><h4 id="P3435-POI2006-OKR-Periods-of-Words"><a href="#P3435-POI2006-OKR-Periods-of-Words" class="headerlink" title="P3435 [POI2006] OKR-Periods of Words"></a><a href="https://www.luogu.com.cn/problem/P3435">P3435 [POI2006] OKR-Periods of Words</a></h4><p>找最大周期可以通过next数组，寻找每一位置最前面的适配位置，因为越前面，周期最大</p><h4 id="P4824-USACO15FEB-Censoring-S"><a href="#P4824-USACO15FEB-Censoring-S" class="headerlink" title="P4824 [USACO15FEB] Censoring S"></a><a href="https://www.luogu.com.cn/problem/P4824">P4824 [USACO15FEB] Censoring S</a></h4><p>从字符串中不断删除模式串，可以在kmp算法中增加栈的运用，每次删除完模式串，可以继续比较删除的两边连接之后会不会形成新的模式串</p><h4 id="P2375-NOI2014-动物园"><a href="#P2375-NOI2014-动物园" class="headerlink" title="P2375 [NOI2014] 动物园"></a><a href="https://www.luogu.com.cn/problem/P2375">P2375 [NOI2014] 动物园</a></h4><p>要找每个子字符串的不重复相等前后缀，可以用个num数组记录每个next数组跳到0需要多少步，这样只要每次找前一半的num为多少即可</p><h3 id="Codeforces-Round-806-Div-4"><a href="#Codeforces-Round-806-Div-4" class="headerlink" title="Codeforces Round #806 (Div. 4)"></a><a href="https://codeforces.com/contest/1703">Codeforces Round #806 (Div. 4)</a></h3><p>ABCDE挺好做的，F题前缀和卡住了，G没时间，后来补题补完了，只是要注意用坏钥匙之后如果二进制 &gt;&gt; 超过32，就可以结束循环，不然会tle</p><h2 id="7-13自主学习"><a href="#7-13自主学习" class="headerlink" title="7.13自主学习"></a>7.13自主学习</h2><blockquote><p>Codeforces Round #806 (Div. 4) <strong>FG题补题</strong>（见昨天）</p><p>Manacher题目</p><p>Trie树</p></blockquote><h3 id="Manacher题目"><a href="#Manacher题目" class="headerlink" title="Manacher题目"></a>Manacher题目</h3><p><a href="https://www.luogu.com.cn/problem/P4555">P4555 [国家集训队]最长双回文串</a></p><p>这题需要在维护p数组的同时维护一下 l [ ] , r [ ] , l [ ] 为以当前 i 为左端点最长的回文串，r [ ] 为以当前 i 为右端点最长的回文串，然后以 ‘ # ’ 为断电，选择最长的双回文串</p><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><h4 id="P3879-TJOI2010-阅读理解"><a href="#P3879-TJOI2010-阅读理解" class="headerlink" title="P3879 [TJOI2010] 阅读理解"></a><a href="https://www.luogu.com.cn/problem/P3879">P3879 [TJOI2010] 阅读理解</a></h4><p>这题用个trie树板子把文章的单词存储起来，并且用bitset维护出现的文章序号</p><h2 id="7-15自主学习"><a href="#7-15自主学习" class="headerlink" title="7.15自主学习"></a>7.15自主学习</h2><blockquote><p>ac自动机</p></blockquote><h4 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h4><p>模板（简单，加强，二次加强），二次加强结合了拓扑排序优化了query</p><h2 id="7-17自主学习"><a href="#7-17自主学习" class="headerlink" title="7.17自主学习"></a>7.17自主学习</h2><blockquote><p>搜索题目</p></blockquote><h4 id="搜索题目（引水入城）"><a href="#搜索题目（引水入城）" class="headerlink" title="搜索题目（引水入城）"></a><a href="https://www.luogu.com.cn/problem/P1514">搜索题目（引水入城）</a></h4><p>这题要验证从一个点搜索到最后一行是一段连续区间，就可以变成区间覆盖问题，只需要dfs第一行每一个点</p>]]></content>
    
    
    <categories>
      
      <category>训练记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>训练记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2022/07/02/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2022/07/02/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> c[a][b];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ ) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ ) &#123;<br>        <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预处理逆元求组合数"><a href="#预处理逆元求组合数" class="headerlink" title="预处理逆元求组合数"></a>预处理逆元求组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> f[N], inv[N];<br><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(ll a, ll k, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>f[<span class="hljs-number">0</span>] = inv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ ) &#123;<br>    f[i] = f[i<span class="hljs-number">-1</span>] * i % mod;<br>    inv[i] = inv[i<span class="hljs-number">-1</span>] * <span class="hljs-built_in">qmi</span>(i,mod<span class="hljs-number">-2</span>,mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lucas定理求组合数"><a href="#Lucas定理求组合数" class="headerlink" title="Lucas定理求组合数"></a>Lucas定理求组合数</h2><p>若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：<br>    C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)ll x, </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ll i = a,j = <span class="hljs-number">1</span>; j &lt;=b; i --, j ++ ) &#123;<br>        x = x * i % p;<br>        y = y * j % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">qmi</span>(y,mod<span class="hljs-number">-2</span>,mod);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">lucas</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b,p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a%p,b%p,p) * <span class="hljs-built_in">lucas</span>(a/p,b/p/p) % p;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆元</title>
    <link href="/2022/06/25/%E9%80%86%E5%85%83/"/>
    <url>/2022/06/25/%E9%80%86%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><p>若a*x≡1(mod b) ,a,b互质，则称x为a的逆元。</p><p>A&#x2F;B %p&#x3D;A*inv(B) %p ,inv(B)为B的逆元。</p><p><strong>如果b过大，可能会爆精度，且除法不满足同于拆分定理。</strong></p><p>求逆元的三种方法：</p><ul><li>费马小定理</li><li>扩展欧几里得求逆元</li><li>逆元线性筛</li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>$$<br>a^{m-1} \equiv 1(mod m) \Rightarrow a *a^{m-2} \equiv 1(mod m)\Rightarrow a^{m-2} \equiv {1 \over a} (modm)<br>$$</p><p>所以a^(m-2)就是a的逆元了。</p><p>计算复杂度为o(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//快速幂</span><br><span class="hljs-function">ll <span class="hljs-title">quickpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll res = <span class="hljs-number">1</span>;<br>    a %= mod;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = (res * a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (a * a) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//求逆元</span><br><span class="hljs-function">ll <span class="hljs-title">inv</span> <span class="hljs-params">(ll a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickpow</span>(a,mod<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p>通过ax+my&#x3D;1，来求x，x为逆元。</p><p>a，m互质。</p><p>复杂度o(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">ex_gcd</span>(b,a%b,x,y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mod_reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d, x, y;<br>    d = <span class="hljs-built_in">ex_gcd</span>(a,b,x,y);<br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> (x % b + b) % b;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逆元线性筛"><a href="#逆元线性筛" class="headerlink" title="逆元线性筛"></a>逆元线性筛</h2><p>求1，2，3……N的逆元。</p><p>复杂度o(N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10005</span>;<br><span class="hljs-type">int</span> inv[maxn];<br>inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10000</span>; i ++ ) &#123;<br>    inv[i] = inv[mod%i] * (mod - mod / i) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉函数</title>
    <link href="/2022/06/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <url>/2022/06/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> prime[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> euler[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">()</span> </span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j ++ ) &#123;<br>            <span class="hljs-type">int</span> t = prime[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                euler[t] = euler[j] * prime[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[j] * (prime[i] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数判定</title>
    <link href="/2022/06/01/%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/"/>
    <url>/2022/06/01/%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="质数判定"><a href="#质数判定" class="headerlink" title="质数判定"></a>质数判定</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> prime[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) prime[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化所有数为素数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">if</span>(prime[i]) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i) prime[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> prime[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j ++) &#123;<br>            st[prime[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树基础</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树基础"><a href="#线段树基础" class="headerlink" title="线段树基础"></a>线段树基础</h1><blockquote><p>线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)).</p><p>线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。</p></blockquote><p>由此看出，用线段树统计的东西，必须符合<strong>区间加法</strong>，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 </p><blockquote><p>符合区间加法的例子：<br>数字之和——总数字之和 &#x3D; 左区间数字之和 + 右区间数字之和<br>最大公因数(GCD)——总GCD &#x3D; gcd( 左区间GCD , 右区间GCD );<br>最大值——总最大值&#x3D;max(左区间最大值，右区间最大值)<br>不符合区间加法的例子：<br>众数——只知道左右区间的众数，没法求总区间的众数<br>01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零</p></blockquote><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>以维护数列区间和的线段树为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> itn;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug puts(<span class="hljs-string">&quot;----------&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem(a,b) memset((a),(b),sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FI first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SE second</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br>ll n, m;<br>ll a[N];<br>ll sum[N&lt;&lt;<span class="hljs-number">2</span>], lazy[N&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">/*****************read()*******************/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ls</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br><span class="hljs-keyword">return</span> rt &lt;&lt; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rs</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br><span class="hljs-keyword">return</span> rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br>sum[rt] = sum[<span class="hljs-built_in">ls</span>(rt)] + sum[<span class="hljs-built_in">rs</span>(rt)];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll ln, ll rn, ll rt)</span> </span>&#123;<br>lazy[<span class="hljs-built_in">ls</span>(rt)] += lazy[rt];<br>lazy[<span class="hljs-built_in">rs</span>(rt)] += lazy[rt];<br>sum[<span class="hljs-built_in">ls</span>(rt)] += lazy[rt] * ln;<br>sum[<span class="hljs-built_in">rs</span>(rt)] += lazy[rt] * rn;<br>lazy[rt] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l, ll r, ll rt)</span> </span>&#123;<br>lazy[rt] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>sum[rt] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(l,mid,<span class="hljs-built_in">ls</span>(rt));<br><span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt));<br><span class="hljs-built_in">push_up</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll rt, ll k)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;<br>sum[rt] += k * (r - l + <span class="hljs-number">1</span>);<br>lazy[rt] += k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">push_down</span>(mid-l+<span class="hljs-number">1</span>,r-mid,rt);<br><span class="hljs-keyword">if</span> (L &lt;= mid) <span class="hljs-built_in">update</span>(L,R,l,mid,<span class="hljs-built_in">ls</span>(rt),k);<br><span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">update</span>(L,R,mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt),k);<br><span class="hljs-built_in">push_up</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">query</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll rt)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="hljs-keyword">return</span> sum[rt];<br>ll ans = <span class="hljs-number">0</span>, mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">push_down</span>(mid-l+<span class="hljs-number">1</span>,r-mid,rt);<br><span class="hljs-keyword">if</span> (L &lt;= mid) ans += <span class="hljs-built_in">query</span>(L,R,l,mid,<span class="hljs-built_in">ls</span>(rt));<br><span class="hljs-keyword">if</span> (R &gt; mid) ans += <span class="hljs-built_in">query</span>(L,R,mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt));<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) a[i] = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (m--) &#123;<br>ll op, x, y, k;<br>op = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">switch</span> (op) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">update</span>(x,y,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,k);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();<br>cout &lt;&lt; <span class="hljs-built_in">query</span>(x,y,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>非递归代码简单，速度快，但是如果要区间修改的话，代码会复杂。</p><ul><li><strong>原数组下标</strong>，是指，需要维护统计信息（比如区间求和）的数组的下标，这里都默认下标从1开始（一般用A数组表示）</li><li><strong>线段树下标</strong>，是指，加入线段树中某个位置的下标，比如，原数组中的第一个数，一般会加入到线段树中的第二个位置，<br>为什么要这么做，后面会讲。</li><li><strong>存储下标</strong>，是指该元素所在的叶节点的编号，即实际存储的位置。</li></ul><p><strong>原数组下标+1&#x3D;线段树下标</strong></p><p><strong>线段树下标+N-1&#x3D;存储下标</strong></p><p>故得到：<strong>原数组下标+N&#x3D;存储下标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100007</span>;<br><span class="hljs-type">int</span> sum[maxn&lt;&lt;<span class="hljs-number">2</span>],add[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[maxn],n,N;<span class="hljs-comment">//m为扩充元素个数</span><br><br><span class="hljs-comment">//建树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    N=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(N&lt;n+<span class="hljs-number">2</span>) N&lt;&lt;=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[N+i]=a[i];<span class="hljs-comment">//原数组下标+N=存储下标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        sum[i]=sum[i&lt;&lt;<span class="hljs-number">1</span>]+sum[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>        add[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//清空懒惰标记</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//单点修改,a[i]+=c</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N+x;i;i&gt;&gt;=<span class="hljs-number">1</span>) sum[i]+=c;<span class="hljs-comment">//更新当前节点和父节点</span><br>&#125;<br><br><span class="hljs-comment">//单点修改完后的区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//s和t都是l~r区间左右两端的节点,在s和t父节点相同时退出</span><br>        <span class="hljs-keyword">if</span>(~s&amp;<span class="hljs-number">1</span>) ans+=sum[s^<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>) ans+=sum[t^<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-type">int</span> s,t,ln=<span class="hljs-number">0</span>,rn=<span class="hljs-number">0</span>,x=<span class="hljs-number">1</span>;<span class="hljs-comment">//ln为s经过的节点数，rn为t经过的节点数，x为本层每个节点包含了几个数</span><br>    <span class="hljs-keyword">for</span>(s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>,x&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//更新sum</span><br>        sum[s]+=c*ln;<br>        sum[t]+=c*rn;<br>        <span class="hljs-comment">//处理add</span><br>        <span class="hljs-keyword">if</span>(~s&amp;<span class="hljs-number">1</span>) add[s^<span class="hljs-number">1</span>]+=c,sum[s^<span class="hljs-number">1</span>]+=c*x,ln+=x;<br>        <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>) add[t^<span class="hljs-number">1</span>]+=c,sum[t^<span class="hljs-number">1</span>]+=c*x,rn+=x;<br>    &#125;<br>    <span class="hljs-comment">//更新上层sum</span><br>    <span class="hljs-keyword">for</span>(;s;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>)&#123;<br>        sum[s]+=c*ln;<br>        sum[t]+=c*rn;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//区间修改完后的区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> s,t,ln=<span class="hljs-number">0</span>,rn=<span class="hljs-number">0</span>,x=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>,x&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//根据标记更新</span><br>        <span class="hljs-keyword">if</span>(add[s]) ans+=add[s]*ln;<br>        <span class="hljs-keyword">if</span>(add[t]) ans+=add[t]*rn;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2022/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2022/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在一给定的无向图G&#x3D;(V,E) 中，(u,v)代表连接顶点u与顶点v的边，而w(u,v) 代表此边的权重，若存在T为E的子集且为无循环图，使得w(T) 最小，则此T为G的最小生成树，因为T是由图G产生的。简单来说，就是经过连通图的每一个点，并且保证边权总和最小。</p><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>prim算法利用贪心的思想实现。任意选定一个节点，从该节点出发，每次选择包含该节点的最短路径，直到遍历所有节点。一般用于稠密图</p><blockquote><p> prim算法与Dijkstra算法区别：<br>Dijkstra算法的数组dis[]含义为起点s达到顶点Vi的最短距离。<br>prim算法的数组dis[]含义为顶点Vi与集合S（已经访问的点集）的最短距离 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-comment">//默认0为初始点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//存放边权之和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-number">0</span>&amp;&amp;(t==<span class="hljs-number">-1</span>||dis[j]&lt;dis[t]))&#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&amp;&amp;dis[t]==INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vis[t]=<span class="hljs-number">1</span>;<br>        ans+=d[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dis[j]=<span class="hljs-built_in">min</span>(dis[j],g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>kruskal算法利用贪心思想实现的，我们先将所有边权从小到大排列，按照顺序选取每条边，如果这条边的两个端点不属于同一个集合，那么将他们合并，直到所有的点都属于同一个集合为止。合并点集我们需要使用到并查集。一般用于稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> edges &amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;edge[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edge,edge+m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a=edge[i].a,b=dege[i].b,w=edge[i].w;<br>        a=<span class="hljs-built_in">find</span>(a),b=<span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[b]=a;<br>            ans+=w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt&lt;n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//无向图不连通，不存在最小生成树</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求最短路</title>
    <link href="/2022/05/01/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/05/01/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="求最短路"><a href="#求最短路" class="headerlink" title="求最短路"></a>求最短路</h1><p>首先先了解一下最短路的框架。</p><blockquote><p><strong>单源最短路：</strong> 求一个点到其他点的最短路<br><strong>多源最短路：</strong> 求任意两个点的最短路</p></blockquote><p>稠密图用邻接矩阵存，稀疏图用<a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&spm=1001.2101.3001.7020">邻接表</a>存储。</p><blockquote><p><strong>稠密图：</strong> m 和 n2 一个级别<br><strong>稀疏图：</strong> m 和 n 一个级别</p></blockquote><h2 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h2><p>floyd<strong>优点</strong>在于代码实现简单。缺点在于<strong>复杂度</strong>为o(n^3)，不能用于大规模数据，多源最短路算法。</p><p>floyd算法可以算带负权的，但是不能算负权回路。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(i==j) d[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> d[i][j]=INF;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//floyd</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//d[a][b]即为a到b的最短路</span><br></code></pre></td></tr></table></figure><h2 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h2><p>dijkstra算法只能用于计算边权都为正的图，是单源最短路算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//邻接矩阵</span><br><br><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dis[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)   <span class="hljs-comment">// 在没有确定最短路中的所有点找出距离最短的那个点 t </span><br>   <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]))<br>    t=j;<br>st[t]=<span class="hljs-literal">true</span>; <span class="hljs-comment">// 代表 t 这个点已经确定最短路了</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++) <span class="hljs-comment">// 用 t 更新其他点的最短距离 </span><br> dis[j] = <span class="hljs-built_in">min</span>(dis[j],dis[t]+g[t][j]);<br> &#125; <br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆优化的dijkstra算法"><a href="#堆优化的dijkstra算法" class="headerlink" title="堆优化的dijkstra算法"></a>堆优化的dijkstra算法</h2><p>朴素版用来计算稠密图，用邻接矩阵存储。而堆优化版用来计算稀疏图，用邻接表存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">//求1号点到n号点的最短距离，如果不存在，返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//first距离  second节点</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-type">int</span> dist=t.first,ver=t.second;<br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dis[j]&gt;dist+w[i])&#123;<br>                dis[j]=dist+w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dis[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ford算法"><a href="#ford算法" class="headerlink" title="ford算法"></a>ford算法</h2><p>ford算法可以用于对于有边数限制要求的最短路，比如求从1号到n号最多经过k条边的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> dis[N],backup[N]; <span class="hljs-comment">//backup数组为上次</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br>   <span class="hljs-type">int</span> a,b,w; <span class="hljs-comment">// a-&gt;b权值为w的边 </span><br>&#125;edge[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) <br>&#123;<br><span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis); <span class="hljs-comment">//备份</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;m; j++)   <span class="hljs-comment">// 枚举所有边 </span><br>&#123;<br>   <span class="hljs-type">int</span> a = edge[j].a, b = edge[j].b, w=edge[j].w;<br>   dis[b] = <span class="hljs-built_in">min</span>(dis[b],backup[a]+w); <span class="hljs-comment">// 用备份更新 </span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dis[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><p>spfa可以计算没有负环的图，可以有负权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dis[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])<br>            &#123;<br>                dis[j] = dis[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa判断有无负环"><a href="#spfa判断有无负环" class="headerlink" title="spfa判断有无负环"></a>spfa判断有无负环</h2><p>如果经过一个环后距离为负，则为负环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dis[N], cnt[N];        <span class="hljs-comment">// dis[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<span class="hljs-comment">//所有节点入队</span><br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])<br>            &#123;<br>                dis[j] = dis[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 说明存在负环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不存在负环</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2022/04/29/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2022/04/29/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>​                    </p><p>​</p><h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><p>二分图判定有两点：</p><ol><li>图为连通图。</li><li>可以分为两个不同的点集。</li></ol><p>一般使用染色法来进行判定，如果每条边两个端点的颜色不同，则说明是二分图。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-comment">//判定</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span></span>&#123;<br>    col[x]=color;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> k=e[i];<br>        <span class="hljs-keyword">if</span>(col[k]==col[x])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不是二分图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!col[k])&#123;<br>            <span class="hljs-built_in">dfs</span>(k,-color);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> k=e[i];<br>        <span class="hljs-keyword">if</span>(!vis[k])&#123;<br>            vis[k]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[k]==<span class="hljs-number">0</span>||<span class="hljs-built_in">find</span>(match[k]))&#123;<span class="hljs-comment">//如果没匹配过或者有还有其他匹配</span><br>                match[k]=x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>st表</title>
    <link href="/2022/04/27/st%E8%A1%A8/"/>
    <url>/2022/04/27/st%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="st表"><a href="#st表" class="headerlink" title="st表"></a><strong>st表</strong></h1><p>什么是st表， st表是一种基于倍增思想，用于解决<strong>可重复贡献问题</strong>的<strong>数据结构</strong>。 st表应用最广泛的领域便是解决RMQ问题：给定n个数，m个询问，对于每个询问，需要回答区间[ l , r ] 中的最大值或最小值(可以采用两个数组同时进行处理)。 除 RMQ 以外，还有其它的“<strong>可重复贡献问题</strong>”。例如“<strong>区间按位和”</strong>、“<strong>区间按位或</strong>”、“<strong>区间 gcd</strong>”，st 表都能高效地解决。 </p><h2 id="st表板子："><a href="#st表板子：" class="headerlink" title="st表板子："></a>st表板子：</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[N][<span class="hljs-number">25</span>];<br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    mn[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        mn[i]=((i&amp;(i<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>)?mn[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>:mn[i<span class="hljs-number">-1</span>];<br>        st[i][<span class="hljs-number">0</span>]=a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=mn[n];j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>            st[i][j]=<span class="hljs-built_in">max</span>(st[i][j<span class="hljs-number">-1</span>],st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<span class="hljs-comment">//这里是求区间最大值</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//查询最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmq_max</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=mn[r-k+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(st[l][k],st[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑序</title>
    <link href="/2022/04/26/%E6%8B%93%E6%89%91%E5%BA%8F/"/>
    <url>/2022/04/26/%E6%8B%93%E6%89%91%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h1><p> 在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。如果有环，则不可能有拓扑序。                                                                                     </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q;<br>vector&lt;<span class="hljs-type">int</span>&gt;e[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;ans;<br><span class="hljs-comment">//入度为0的点入队</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-type">int</span> k=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    ans.<span class="hljs-built_in">push_back</span>(k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;e[p].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> y=e[k][i];<br>        in[y]--;<br>        <span class="hljs-keyword">if</span>(in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果ans的长度为n，则说明这个图具有拓扑序列，否则不具有。</p><p>并且如果需要按照字典序输出字典序最大的拓扑序，可以室友priority_queue（优先队列）即可。</p>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lca</title>
    <link href="/2022/04/25/lca/"/>
    <url>/2022/04/25/lca/</url>
    
    <content type="html"><![CDATA[<h1 id="LCA算法"><a href="#LCA算法" class="headerlink" title="LCA算法"></a>LCA算法</h1><p>LCA（Least Common Ancestors），即最近公共祖先，指对于有根树 T 的两个结点 u 、v ，最近公共祖先 LCA(T,u,v) 表示一个结点 x, 满足 x 是 u、v 的祖先且 x 的深度尽可能大。</p><p>求解lca的四种方法：</p><ol><li><p>用倍增法求解，预处理复杂度是 O(nlogn)O(nlog⁡n) ,每次询问的复杂度是 O(logn)O(log⁡n), 属于在线解法。</p></li><li><p>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)O(n+nlog⁡n) ，每次询问的复杂度为 O(1)O(1)， 也是在线算法。</p></li><li><p>采用Tarjan算法求解，复杂度 O(α(n)+Q)O(α(n)+Q) ，属于离线算法。</p></li><li><p>利用树链剖分求解，复杂度预处理O(n)O(n) ，单次查询 O(logn)O(log⁡n) ，属于在线算法。</p></li></ol><p><strong>当然，第四种树链剖分表示不会，这里就不展开了。</strong></p><h2 id="倍增法求lca"><a href="#倍增法求lca" class="headerlink" title="倍增法求lca"></a>倍增法求lca</h2><p> 最常用，也是最简单的算法，实质就是直接对暴力使用倍增优化将复杂度降低达到需求。 </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存每个节点连接的节点</span><br>fa[][];<br>dep[];<br>vis[];<br><span class="hljs-comment">//dfs预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];i++) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(vis[e[i]]) <span class="hljs-keyword">continue</span>;<br>        vis[e[i]]=<span class="hljs-literal">true</span>;<br>        dep[e[i]]=dep[x]+<span class="hljs-number">1</span>;<br>        fa[e[i]][<span class="hljs-number">0</span>]=x;<br>        <span class="hljs-built_in">dfs</span>(e[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//lca</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[u]&lt;dep[v]) <span class="hljs-built_in">swap</span>(u,v);<br>    <span class="hljs-type">int</span> k=<span class="hljs-built_in">log2</span>(dep[u]-dep[v]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(dep[fa[u][i]]&gt;=dep[v]) u=dp[u][i];<span class="hljs-comment">//跳到同一高度</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> u;<br>    k=<span class="hljs-built_in">log2</span>(dep[u]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//跳到lca的下一层</span><br>        <span class="hljs-keyword">if</span>(fa[u][i]==fa[v][i]) <span class="hljs-keyword">continue</span>;<br>        u=fa[u][i];<br>        v=fa[v][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回lca下一层的父节点，即lca节点</span><br>&#125;<br><br><span class="hljs-comment">//初始化</span><br>dep[s]=<span class="hljs-number">1</span>;<br>vis[s]=<span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><h2 id="欧拉序-st表"><a href="#欧拉序-st表" class="headerlink" title="欧拉序+st表"></a>欧拉序+st表</h2><p>学了st表，建议用这个，这个套用一个st表代码实现会比较方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> dep)</span></span>&#123;<br>first[u]=++tot;<span class="hljs-comment">//每个节点第一次出现在欧拉序上的位置</span><br>ver[tot]=u;<span class="hljs-comment">//欧拉序</span><br>deep[u]=dep;每个节点的深度<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(!first[j])&#123;<br><span class="hljs-built_in">dfs</span>(j,dep+<span class="hljs-number">1</span>);<br>ver[++tot]=u;<span class="hljs-comment">//每次dfs之后都要返回原来的u节点</span><br>deep[u]=dep;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>mn[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;<br>mn[i]=((i&amp;(i<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>?mn[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>:mn[i<span class="hljs-number">-1</span>];<br>st[i][<span class="hljs-number">0</span>]=ver[i];<span class="hljs-comment">//st表存储欧拉序上的节点</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=mn[tot];j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=tot;i++)&#123;<br><span class="hljs-keyword">if</span>(deep[st[i][j<span class="hljs-number">-1</span>]]&lt;deep[st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]])&#123;<span class="hljs-comment">//按照深度大小dp</span><br>st[i][j]=st[i][j<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">else</span> st[i][j]=st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查询</span><br><span class="hljs-type">int</span> u,v;<br>u=first[u];<br>v=first[v];<br><span class="hljs-keyword">if</span>(u&gt;v) <span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-type">int</span> k=mn[v-u+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(deep[st[u][k]]&lt;deep[st[v-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]])&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, st[u][k]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, st[v-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>板子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2022/04/25/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/04/25/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p>树的直径就是树上最远两点的距离。这里介绍复杂度O(n) 的解法，即两次dfs（或者bfs）来求取直径。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>从任意一点P出发，通过DFS寻找离它最远的点Q。</li><li>再次从点Q出发，通过DFS寻找离它最远的W。</li><li>直径即为WQ。</li></ol><p> <u>该算法的优点是，可以得知整条直径上的所有节点（尤其得知了端点），便于其他的操作。</u> </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs搜索距离st最远的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> t=edge[st][i];<span class="hljs-comment">//t为连接st的节点</span><br>        <span class="hljs-keyword">if</span>(!vis[t])&#123;<br>            vis[t]=<span class="hljs-number">1</span>;<br>            dis[t]=dis[st]+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的重心</title>
    <link href="/2022/04/24/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    <url>/2022/04/24/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><p> <strong>树的重心又叫树的质心</strong>：对于一颗n个节点的无根树，找到一个点，使得把树变成以该节点为根的有根树时，最大子树的节点数最少。换句话说，删除这个节点后最大连通块（一定是树）的节点数最少。 </p><h2 id="树的重心性质"><a href="#树的重心性质" class="headerlink" title="树的重心性质"></a>树的重心性质</h2><ol><li>树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。</li><li>把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。</li><li>一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。</li><li>一棵树最多有两个重心，且相邻。</li></ol><p><strong>考点</strong>：树形dp+dfs</p><h3 id="dfs部分"><a href="#dfs部分" class="headerlink" title="dfs部分"></a>dfs部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录u节点的最大子节点数</span><br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录u为根的节点数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<span class="hljs-comment">//链式前向星存每个节点连接的节点</span><br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(vis[j]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> s=<span class="hljs-built_in">dfs</span>(j);<br>        size=<span class="hljs-built_in">max</span>(size,s);<br>        sum+=s;<br>    &#125;<br>    ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">max</span>(size,n-sum));<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树真是个<del>可爱</del>的东西呢（我要烦死了）。                                                                                </p><p>​                                      </p><h2 id="先序中序求后序层次遍历"><a href="#先序中序求后序层次遍历" class="headerlink" title="先序中序求后序层次遍历"></a>先序中序求后序层次遍历</h2><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-type">int</span> l,r;<br>&#125;tree[N];<br><span class="hljs-type">int</span> in[N],post[N];<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mp;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> prel,<span class="hljs-type">int</span> prer)</span></span>&#123;<br><span class="hljs-keyword">if</span>(inl&gt;inr||prel&gt;prer) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> rt=pre[prel];<br><span class="hljs-type">int</span> index=mp[rt];<br><span class="hljs-type">int</span> pos=++p;<br><span class="hljs-type">int</span> l=index-inl;<br>t[pos].data=rt;<br>t[pos].l=<span class="hljs-built_in">build</span>(inl,index<span class="hljs-number">-1</span>,prel+<span class="hljs-number">1</span>,prel+l);<br>t[pos].r=<span class="hljs-built_in">build</span>(index+<span class="hljs-number">1</span>,inr,prel+l+<span class="hljs-number">1</span>,prer);<br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(t[u].left!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(t[u].left);<br>    <span class="hljs-keyword">if</span>(t[u].right!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(t[u].right);<br>    cout&lt;&lt;t[u].data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//层次遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;tree[u].data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; <br><span class="hljs-keyword">if</span>(tree[u].l!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(tree[u].l);<br><span class="hljs-keyword">if</span>(tree[u].r!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(tree[u].r);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="后序中序求先序层次遍历"><a href="#后序中序求先序层次遍历" class="headerlink" title="后序中序求先序层次遍历"></a>后序中序求先序层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> postl,<span class="hljs-type">int</span> postr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(inl&gt;inr||postl&gt;postr) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//结束</span><br>    <span class="hljs-type">int</span> now=post[postr];<br>    <span class="hljs-type">int</span> index=mp[now];<br>    <span class="hljs-type">int</span> pos=++p;<br>    <span class="hljs-type">int</span> len=index-inl;<br>    t[pos].data=now;<br>    t[pos].left=<span class="hljs-built_in">build</span>(inl,index<span class="hljs-number">-1</span>,postl,prel+len<span class="hljs-number">-1</span>);<br>    t[pos].right=<span class="hljs-built_in">build</span>(index+<span class="hljs-number">1</span>,inr,post+len,postr<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> pos;<span class="hljs-comment">//返回当前指针位置</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组进阶</title>
    <link href="/2022/04/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/04/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组进阶"><a href="#树状数组进阶" class="headerlink" title="树状数组进阶"></a>树状数组进阶</h1><p>我们可以使用<del>可爱的</del>树状数组实现什么呢？</p><h2 id="求逆序对"><a href="#求逆序对" class="headerlink" title="求逆序对"></a>求逆序对</h2><p><strong>树状数组+离散化</strong></p><p>假设此时已经将a[]离散化处理成了b[]，最后的ans即为逆序对个数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]++;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        res+=c[x];<br>            x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//离散化比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[x]==a[y]) <span class="hljs-keyword">return</span> x&gt;y;<br>    <span class="hljs-keyword">return</span> a[x]&gt;a[y];<br>&#125;<br><br><span class="hljs-comment">//a的逆序对个数为</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-built_in">update</span>(d[i]);<br>    ans+=<span class="hljs-built_in">getsum</span>(d[i]<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求区间最大值"><a href="#求区间最大值" class="headerlink" title="求区间最大值"></a>求区间最大值</h2><p><strong>单点更新+区间查询</strong></p><p>单点更新复杂度为O(logn*logn)</p><p>区间查询复杂度为O(logn*logn)</p><p>运用分块思想，将区间l~r通过lowbit分成多块，再将每块的最大值合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]=a[x];<span class="hljs-comment">//每次先更新自身</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">lowbit</span>(x);i&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>            c[x]=<span class="hljs-built_in">max</span>(c[x],c[x<span class="hljs-number">-1</span>]);<br>            x+=<span class="hljs-built_in">lowbit</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(r&gt;=l)&#123;<br>        ans=<span class="hljs-built_in">max</span>(ans,a[r]);<br>        r--;<br>        <span class="hljs-keyword">for</span>(r;<span class="hljs-built_in">lowbit</span>(r)&gt;=l;r-=<span class="hljs-built_in">lowbit</span>(r))&#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,h[r]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本操作进阶版"><a href="#基本操作进阶版" class="headerlink" title="基本操作进阶版"></a>基本操作进阶版</h2><p>继树状数组基础里面的<strong>单点修改+区间查询</strong>，我们可以使用差分，进而实现<strong>区间修改+单点查询</strong></p><h2 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改+单点查询"></a>区间修改+单点查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]+=y;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>        sum+=c[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">update</span>(i,a[i]-a[i<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-built_in">update</span>(l,k);<br><span class="hljs-built_in">update</span>(r+<span class="hljs-number">1</span>,-k);<br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">query</span>(x);<br></code></pre></td></tr></table></figure><h2 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改+区间查询"></a>区间修改+区间查询</h2><p>区间查询和上面的单点查询有些区别，需要两个数组c[],c1[]。假设相邻两数a[i],a[i-1]的差分为bi，则c维护bi，c1维护i*bi</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> *p,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        p[x]+=y;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,temp=x;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>        sum+=(temp)*c[x]-c1[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">update</span>(c,i,a[i]-b);<br>    <span class="hljs-built_in">update</span>(c1,i,(i<span class="hljs-number">-1</span>)*(a[i]-b);<br>   b=a[i];<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-built_in">update</span>(c,l,k);<br><span class="hljs-built_in">update</span>(c,r+<span class="hljs-number">1</span>,-k);<br><span class="hljs-built_in">update</span>(c1,l,(l<span class="hljs-number">-1</span>)*k);<br><span class="hljs-built_in">update</span>(c1,r+<span class="hljs-number">1</span>,-r*k);<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-built_in">query</span>(r)-<span class="hljs-built_in">query</span>(l<span class="hljs-number">-1</span>);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三元上升子序列</title>
    <link href="/2022/04/19/%E4%B8%89%E5%85%83%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/04/19/%E4%B8%89%E5%85%83%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="三元上升子序列"><a href="#三元上升子序列" class="headerlink" title="三元上升子序列"></a><a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Erwin 最近对一种叫 <code>thair</code> 的东西巨感兴趣。。。</p><p>在含有 n 个整数的序列 a1,a2,,…,an中，三个数被称作<code>thair</code>当且仅当 i&lt;j&lt;k<em>i</em>&lt;<em>j</em>&lt;<em>k</em> 且 a_i&lt;a_j&lt;a_k<em>a**i</em>&lt;<em>a**j</em>&lt;<em>a**k</em>。</p><p>求一个序列中 <code>thair</code> 的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>开始一行一个正整数 n<em>n</em>,</p><p>以后一行 n<em>n</em> 个整数 a_1,a_2,\ldots,a_n<em>a</em>1,<em>a</em>2,…,<em>a**n</em>。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p> 一行一个整数表示 <code>thair</code> 的个数。 </p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入#1"></a>输入#1</h3><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出#1</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>输入#2</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出#7</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="说明-x2F-提示"><a href="#说明-x2F-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><h4 id="样例2-解释"><a href="#样例2-解释" class="headerlink" title="样例2 解释"></a>样例2 解释</h4><p>7个 <code>thair</code> 分别是：</p><ul><li>1 2 3</li><li>1 2 4</li><li>1 2 3</li><li>1 2 4</li><li>1 3 4</li><li>2 3 4</li><li>2 3 4</li></ul><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30%30% 的数据 保证 n\le100<em>n</em>≤100；</li><li>对于 60%60% 的数据 保证 n\le2000<em>n</em>≤2000；</li><li>对于 100%100% 的数据 保证 1 \leq n\le3\times10^41≤<em>n</em>≤3×104，0\le a_i\lt 10^50≤<em>a**i</em>&lt;105。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先这题的思路可以枚举中间数j，然后再求j左边比它小的数的个数，以及j右边比它大的数的个数，两数相乘即为中间数j对答案的贡献值，枚举的复杂度为O(n)。</p><p>那么，为什么这题需要树状数组呢，树状数组复杂度为O(logn)，每次枚举j的时候，都要求左边以及右边的前缀和，由于无规则排列，光前缀和没法实现，那么便需要树状数组加上离散化，动态求解前缀和。</p><p>拥有了树状数组的基础知识之后，就来讲一下离散化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>    cin&gt;&gt;a[i];<br>    a1[i]=a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+n);<br>m=<span class="hljs-built_in">unique</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+n)-(a1+<span class="hljs-number">1</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Q</span><span class="hljs-params">(ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+m,val)-a1;<br>&#125;<br></code></pre></td></tr></table></figure><p>a1为离散化数组，将a1数组重排列之后去重，m即离散化数组的长度。函数Q返回val离散化的值。这样一来，权值树状数组便诞生了。</p><p>我们再创建一个序列，记录每个数字出现的次数。便于树状数组维护其前缀和。</p><p>接下来就是求解j左右个数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>    <span class="hljs-built_in">update</span>(<span class="hljs-built_in">Q</span>(a[i]),<span class="hljs-number">1</span>);<br>    l[i]=<span class="hljs-built_in">getsum</span>(<span class="hljs-built_in">Q</span>(a[i])<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>&#123;<br>    <span class="hljs-built_in">update</span>(<span class="hljs-built_in">Q</span>(a[i]),<span class="hljs-number">1</span>);<br>    r[i]=n-i-(<span class="hljs-built_in">getsum</span>(<span class="hljs-built_in">Q</span>(a[i]))<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e4</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[N],s[N],c[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l[N],r[N];<br><br><span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll val)</span></span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;N) c[x]+=val,x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>) ans+=c[x],x-=<span class="hljs-built_in">lowbit</span>(x);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">q</span><span class="hljs-params">(ll val)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+m,val)-s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>s[i]=a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n);<br>m=<span class="hljs-built_in">unique</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n)-s<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">q</span>(a[i]),<span class="hljs-number">1</span>);<br>l[i]=<span class="hljs-built_in">query</span>(<span class="hljs-built_in">q</span>(a[i])<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> c);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">q</span>(a[i]),<span class="hljs-number">1</span>);<br>r[i]=n-i-(<span class="hljs-built_in">query</span>(<span class="hljs-built_in">q</span>(a[i]))<span class="hljs-number">-1</span>);<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>ans+=l[i]*r[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组基础</title>
    <link href="/2022/04/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组基础"><a href="#树状数组基础" class="headerlink" title="树状数组基础"></a>树状数组基础</h1><p>树状数组是一个查询和修改复杂度都为log(n)的数据结构。 </p><p>学习树状数组，需要习惯使用二进制的思维。树状数组的更新和查询过程类似一颗<strong>二叉树</strong>。树状数组需要长度n，一个初始的数组（我们记为a[]，以及一个新的数组（我们记为c[]，这里的思路有点类似于前缀和）。</p><h2 id="结构根本"><a href="#结构根本" class="headerlink" title="结构根本"></a>结构根本</h2><ol><li><code>更新</code>过程时，每个根节点相当于他的子节点加上子节点的最低位1。 (101 + 1 -&gt;110, 110 + 10 -&gt; 1000, 1000 + 1000 -&gt; 10000) </li><li><code>查询</code>过程时，每个根节点相当于去掉了根节点最低位1。 (1111 - 1 -&gt; 1110, 1110  - 10 -&gt; 1100, 1100 - 100 -&gt; 1000)</li></ol><p>那么！树状数组的精髓就在于如何取当前最低位1，我们通常使用lowbit(x)，树状数组的优势便在于lowbit极为简短。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br></code></pre></td></tr></table></figure><p> 以二进制数11010为例:11010的补码为00101,加1后为00110,两者相与便是最低位的1 。所以我们只需要进行x&amp;(-x)就可以取出最低位的1了，会了lowbit,我们就可以进行区间查询和单点更新了!!!</p><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>每次更新一个点，比如更新a[1]。那么之后n之内的所有根节点，都需要更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        c[i]+=y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>查询即为更新逆操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        ans+=c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么一来，树状数组最基本的两种操作我们便学会了。^_^</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/19/hello-world/"/>
    <url>/2022/04/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
