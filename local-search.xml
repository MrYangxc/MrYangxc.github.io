<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>牛客数论刷题之旅1~10题</title>
    <link href="/2022/11/01/%E7%89%9B%E5%AE%A2%E6%95%B0%E8%AE%BA%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%851-10%E9%A2%98/"/>
    <url>/2022/11/01/%E7%89%9B%E5%AE%A2%E6%95%B0%E8%AE%BA%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%851-10%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="第一题-约数个数的和"><a href="#第一题-约数个数的和" class="headerlink" title="第一题 约数个数的和"></a><a href="(https://ac.nowcoder.com/acm/problem/14682)">第一题 约数个数的和</a></h2><p><strong>题目描述：</strong> 给个n，求1到n的所有数的约数个数的和</p><p><strong>解题过程：</strong>开始的想法是遍历1到n的然后用求约数的公式（a的约数个数为(1+c1)(1+c2)…)但是n最大1e8会T，后来换了想法遍历约数1到n，则每个约数出现的个数为n&#x2F;i。</p><p><strong>心得：</strong>遍历的时候可以遍历可能出现更多的量，比如这题所求的数每个只出现一次，但是同样1到n范围的约数，每个会出现多次。</p><h2 id="第二题-集合中的质数"><a href="#第二题-集合中的质数" class="headerlink" title="第二题 集合中的质数"></a><a href="https://ac.nowcoder.com/acm/problem/14686">第二题 集合中的质数</a></h2><p><strong>题目描述：</strong>给出一个集合和一个数m，集合里面有n个质数，请你求出从 1 到 m 的所有数中，至少能被集合中的一个数整除的数的个数。</p><p><strong>解题过程：</strong>发现n的数据范围只有20，又发现题目里出现至少被一个整除，于是想到了容斥原理。这题利用容斥原理能快速ac。</p><h3 id="珂朵莉的数论题"><a href="#珂朵莉的数论题" class="headerlink" title=" 珂朵莉的数论题 "></a><a href="https://ac.nowcoder.com/acm/problem/14832"> 珂朵莉的数论题 </a></h3><p><strong>题目描述：</strong>珂朵莉想求：第x小的正整数v使得其最小的质因数为质数y，即正好有x-1个[1,v-1]之内的正整数满足其最小的质因数为质数y，若答案超过1000000000则输出0。</p><p><strong>解题过程：</strong>这题一开始没有头绪，是去搜的题解，csdn搜的题解是判断y的大小，y较小用容斥加二分，y较大则是直接线性筛。但是后来发现了个更巧妙的方法，方法如下：</p><p>本题可以理解成y*k，k包含比y大的数，k从y开始每次加2，因为y &gt; 2之后所有的质因数都是奇数，对于每一个k，定义一个j从3开始到y，如果k能整除j，说明有比y小的质因数，则这个k不成立，如果j大于等于y，说明这个k成立，x–。这个方法通过从y开始逐渐增大，达到排序的效果，且确保了复杂度在o(n)。</p>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国剩余定理</title>
    <link href="/2022/10/29/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <url>/2022/10/29/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>中国剩余定理是用来求解一堆线性同余方程组的通解的算法。</p><p>例如： <em>x</em> ≡ <em>a</em>i (<em>m</em>o<em>d</em>  <em>m</em>i) i &#x3D; 1,2,3…  其中，<em>m</em>1，<em>m</em>2，… ，<em>m</em>n两两互质。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-type">int</span> n;<br>ll a[<span class="hljs-number">30</span>],m[<span class="hljs-number">30</span>],M = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">算法步骤:</span><br><span class="hljs-comment">计算模数积，然后遍历每个方程，让答案累加a[i]*M/m[i]*inv(M/m[i],m[i]);</span><br><span class="hljs-comment">其中inv(a,b)表示a在modb意义下的逆元。</span><br><span class="hljs-comment">注意，中国剩余定理必须要满足模数两两互质。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; T <span class="hljs-title">gcd</span><span class="hljs-params">(T a, T b)</span></span>&#123;<br><span class="hljs-keyword">return</span> !b?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!b)&#123;<br>x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>y -= a/b*x;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a, ll b)</span></span>&#123;<br>ll x,y;<br><span class="hljs-built_in">exgcd</span>(a,b,x,y);<br><span class="hljs-keyword">return</span> (x%b+b)%b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m[i],&amp;a[i]);<br>M *= m[i];<br>&#125;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>ans = (ans + a[i]*M/m[i]*<span class="hljs-built_in">inv</span>(M/m[i],m[i]))%M;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ans%M + M)%M);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><p>于中国剩余定理相比，模数不再两两互质，所以同余方程组可能无解。</p><p>其算法通过n-1次循环将n隔方程合并为一个方程，最后得到整个方程组的通解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a,ll b,ll mod)</span></span>&#123;<span class="hljs-comment">//O(1)取模快速乘，不会爆long long</span><br><span class="hljs-keyword">return</span> (a*b-(ll)((<span class="hljs-type">long</span> <span class="hljs-type">double</span>)a/mod*b)*mod+mod)%mod;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll&amp; x, ll&amp; y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!b)&#123;<br>x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br>ll d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>y -= a/b*x;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>ll a1,m1;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m1,&amp;a1);<br><span class="hljs-type">bool</span> ok = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>ll a2,m2,k1,k2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;m2,&amp;a2);<br>ll d = <span class="hljs-built_in">exgcd</span>(m1,m2,k1,k2);<br><span class="hljs-keyword">if</span>((a2-a1)%d) ok = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>k1 = <span class="hljs-built_in">mul</span>(k1,(a2-a1)/d,m2/d);<span class="hljs-comment">//这个地方必须要用取模快速乘</span><br>a1 = a1+k1*m1;<br>m1 = <span class="hljs-built_in">abs</span>(m1/d*m2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ok)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(a1%m1+m1)%m1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tarjan</title>
    <link href="/2022/07/29/tarjan/"/>
    <url>/2022/07/29/tarjan/</url>
    
    <content type="html"><![CDATA[<h1 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>     <span class="hljs-type">int</span> v,next;<br> &#125;edge[<span class="hljs-number">1001</span>];<br>  <span class="hljs-type">int</span> DFN[<span class="hljs-number">1001</span>],LOW[<span class="hljs-number">1001</span>];<br> <span class="hljs-type">int</span> stack[<span class="hljs-number">1001</span>],heads[<span class="hljs-number">1001</span>],visit[<span class="hljs-number">1001</span>],cnt,tot,index;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>     edge[++cnt].next=heads[x];<br>     edge[cnt].v = y;<br>     heads[x]=cnt;<br>    <span class="hljs-keyword">return</span> ;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//代表第几个点在处理。递归的是点。</span></span><br><span class="hljs-function"> </span>&#123;<br>     DFN[x]=LOW[x]=++tot;<span class="hljs-comment">// 新进点的初始化。</span><br>     stack[++index]=x;<span class="hljs-comment">//进站</span><br>     visit[x]=<span class="hljs-number">1</span>;<span class="hljs-comment">//表示在栈里</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=heads[x];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<br>     &#123;<br>         <span class="hljs-keyword">if</span>(!DFN[edge[i].v]) &#123;<span class="hljs-comment">//如果没访问过</span><br>            <span class="hljs-built_in">tarjan</span>(edge[i].v);<span class="hljs-comment">//往下进行延伸，开始递归</span><br>             LOW[x]=<span class="hljs-built_in">min</span>(LOW[x],LOW[edge[i].v]);<span class="hljs-comment">//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visit[edge[i].v ])&#123;  <span class="hljs-comment">//如果访问过，并且还在栈里。</span><br>             LOW[x]=<span class="hljs-built_in">min</span>(LOW[x],DFN[edge[i].v]);<span class="hljs-comment">//比较谁是谁的儿子／父亲。就是链接对应关系</span><br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">if</span>(LOW[x]==DFN[x]) <span class="hljs-comment">//发现是整个强连通分量子树里的最小根。</span><br>    &#123;<br>         <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,stack[index]);<br>             visit[stack[index]]=<span class="hljs-number">0</span>;<br>             index--;<br>         &#125;<span class="hljs-keyword">while</span>(x!=stack[index+<span class="hljs-number">1</span>]);<span class="hljs-comment">//出栈，并且输出。</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> ;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">memset</span>(heads,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(heads));<br>     <span class="hljs-type">int</span> n,m;<br>     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">int</span> x,y;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>     &#123;<br>         <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        <span class="hljs-built_in">add</span>(x,y);<br>     &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>         <span class="hljs-keyword">if</span>(!DFN[i])  <span class="hljs-built_in">tarjan</span>(i);<span class="hljs-comment">//当这个点没有访问过，就从此点开始。防止图没走完</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ac自动机</title>
    <link href="/2022/07/16/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2022/07/16/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trie</span> &#123;<br><span class="hljs-type">int</span> ch[<span class="hljs-number">27</span>];<br><span class="hljs-type">int</span> fail, ed;<br>&#125;t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br><span class="hljs-type">int</span> u = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!t[p].ch[u]) t[p].ch[u] = ++ idx;<br>p = t[p].ch[u];<br>&#125;<br>t[p].ed ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_fail</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>].ch[i]) &#123;<br>t[t[<span class="hljs-number">0</span>].ch[i]].fail = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(t[<span class="hljs-number">0</span>].ch[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (t[p].ch[i]) &#123;<br>t[t[p].ch[i]].fail = t[t[p].fail].ch[i];<br>q.<span class="hljs-built_in">push</span>(t[p].ch[i]);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>t[p].ch[i] = t[t[p].fail].ch[i];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>p = t[p].ch[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = p; u &amp;&amp; t[u].ed != <span class="hljs-number">-1</span>; u = t[u].fail) &#123;<br>ans += t[u].ed;<br>t[u].ed = <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>字符串</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manacher算法</title>
    <link href="/2022/07/12/manacher%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/12/manacher%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">3e7</span>;<br><span class="hljs-type">char</span> s[maxn], t[maxn];<br><span class="hljs-type">int</span> p[maxn];<br><br><span class="hljs-comment">//将字符串扩展</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>t[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;&amp;&#x27;</span>;<br><span class="hljs-type">int</span> l = <span class="hljs-built_in">strlen</span>(s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i ++ ) &#123;<br>t[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>t[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>] = s[i];<br>&#125;<br>t[l*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>t[l*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> maxx = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i ++ ) &#123;<br><span class="hljs-keyword">if</span> (maxx &gt; i) p[i] = <span class="hljs-built_in">min</span>(p[pos*<span class="hljs-number">2</span>-i], maxx - i);<br><span class="hljs-keyword">else</span> p[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (t[i-p[i]] == t[i+p[i]]) p[i] ++;<br><span class="hljs-keyword">if</span> (i + p[i] &gt; maxx) &#123;<br>maxx = i + p[i];<br>pos = i;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(ans,p[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>字符串</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/07/08/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/08/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;&quot;</span>, p = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = p.<span class="hljs-built_in">length</span>();<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br>p = <span class="hljs-string">&quot; &quot;</span> + p;<br><span class="hljs-comment">//求next</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ ) &#123;<br><span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br><span class="hljs-keyword">if</span> (p[i] == p[j+<span class="hljs-number">1</span>]) j ++;<br>ne[i] = j;<br>&#125; <br><span class="hljs-comment">//模式串匹配 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) &#123;<br><span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br><span class="hljs-keyword">if</span> (s[i] == p[j+<span class="hljs-number">1</span>]) j ++;<br><span class="hljs-keyword">if</span> (j == m) &#123;<br>j = ne[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>字符串</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/07/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/07/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><h2 id="自然溢出"><a href="#自然溢出" class="headerlink" title="自然溢出"></a>自然溢出</h2><p>最快的，也是安全系数比较低的哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">131</span>;<br>ull a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function">ull <span class="hljs-title">hsh</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = ans * base + (ull)s[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单哈希"><a href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> base = <span class="hljs-number">131</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hsh</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base + (ull)s[i]) % mod;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base1 = <span class="hljs-number">131</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> base2 = <span class="hljs-number">29</span>;<br><span class="hljs-type">const</span> ull mod1 = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> ull mod2 = <span class="hljs-number">1e9</span> + <span class="hljs-number">9</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> x, y;<br>&#125;a[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">hsh1</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base1 + (ull)s[i]) % mod1;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ull <span class="hljs-title">hsh2</span><span class="hljs-params">(string s)</span> </span>&#123;<br>ull ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++ ) &#123;<br>ans = (ans * base2 + (ull)s[i]) % mod2;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022暑假训练内容</title>
    <link href="/2022/07/07/2022%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E5%86%85%E5%AE%B9/"/>
    <url>/2022/07/07/2022%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>本篇博客主要记录2022年暑假训练的内容，其中包含自己学习的算法，刷的题目，杭电多校被虐的题目，以及对于一个暑假学习的心得体会                                                                                                                                                                   </p><h2 id="7-7自主学习"><a href="#7-7自主学习" class="headerlink" title="7.7自主学习"></a>7.7自主学习</h2><ul><li>组合数三种方法</li><li>2021 Jiangsu Collegiate Programming Contest</li></ul><h3 id="组合数三种方法"><a href="#组合数三种方法" class="headerlink" title="组合数三种方法"></a>组合数三种方法</h3><ol><li>递推法求组合数</li><li>预处理逆元求组合数</li><li>Lucas定理求组合数</li></ol><h3 id="2021-Jiangsu-Collegiate-Programming-Contest"><a href="#2021-Jiangsu-Collegiate-Programming-Contest" class="headerlink" title="2021 Jiangsu Collegiate Programming Contest"></a>2021 Jiangsu Collegiate Programming Contest</h3><h4 id="A-Spring-Couplets"><a href="#A-Spring-Couplets" class="headerlink" title="A. Spring Couplets"></a><a href="(https://codeforces.com/gym/103495/problem/A)">A. Spring Couplets</a></h4><blockquote><p>给一副对联，判断是否满足平仄规则</p><p>关键词：模拟</p></blockquote><p>这里我一开始没注意到每个字都要对应平仄相反，这道题直接模拟一遍即可</p><h4 id="C-Magical-Rearrangement"><a href="#C-Magical-Rearrangement" class="headerlink" title="C. Magical Rearrangement"></a><a href="(https://codeforces.com/gym/103495/problem/C)">C. Magical Rearrangement</a></h4><blockquote><p>使用给定的数字集合构造一个尽可能小的相邻数字不同的数，不允许有前导零（单独一个 0 不算前导零）</p><p>关键词：贪心，分类讨论 </p></blockquote><p>这也是一道考思维的题目，其中分几类讨论即可</p><h4 id="I-Fake-Walsh-Transform"><a href="#I-Fake-Walsh-Transform" class="headerlink" title="I. Fake Walsh Transform"></a><a href="(https://codeforces.com/gym/103495/problem/I)">I. Fake Walsh Transform</a></h4><blockquote><p>用 0 到 2^m - 1 范围内（包括两端）尽可能多的数的异或和表示 n，求最多可以用多少个数来表示 </p><p>关键词：分类讨论  </p></blockquote><p>从0到2 ^ m - 1所有数异或之和为0（m &gt; 1），所以只要特判m &#x3D; 1 的情况，其他时候不取 n 就行了</p><h4 id="J-Anti-merge"><a href="#J-Anti-merge" class="headerlink" title="J. Anti-merge"></a><a href="(https://codeforces.com/gym/103495/problem/J)">J. Anti-merge</a></h4><blockquote><p>对于一个数表，对于相同的单元格进行合并，优先合并相同内容的行，再合并高度相同且行内容相同的列。现在想让所有的单元格都不会合并，方法是添加一些标记。问需要至少要给多少单元格添加标记，至少添加多少种标记</p><p>关键词：BFS，黑白染色   </p></blockquote><p>这题只需要对整个图进行bfs，然后选取每个连通块染色相对少的数量就好了</p><h4 id="K-Longest-Continuous-1"><a href="#K-Longest-Continuous-1" class="headerlink" title="K. Longest Continuous 1"></a><a href="https://codeforces.com/gym/103495/problem/K">K. Longest Continuous 1</a></h4><blockquote><p>将 0, 1, 2, . . . 不含前导 0 的二进制形式依次拼接成一个字符串，求长度为 k 的前缀中最长连续 1 的长度 </p><p>关键词：二分，打表 </p></blockquote><p>这题可以通过找规律验证发现每次加上2 ^ m - 1 时会有最大前导 0，所以可以打表寻找那个临界长度，然后每次二分查找或者线性查找即可</p><h2 id="7-8自主学习"><a href="#7-8自主学习" class="headerlink" title="7.8自主学习"></a>7.8自主学习</h2><blockquote><p>2021 Jiangsu Collegiate Programming Contest</p><p>字符串哈希三种方法</p><p>kmp算法</p></blockquote><h3 id="2021-Jiangsu-Collegiate-Programming-Contest-1"><a href="#2021-Jiangsu-Collegiate-Programming-Contest-1" class="headerlink" title="2021 Jiangsu Collegiate Programming Contest"></a>2021 Jiangsu Collegiate Programming Contest</h3><h4 id="D-Pattern-Lock"><a href="#D-Pattern-Lock" class="headerlink" title="D. Pattern Lock"></a><a href="https://codeforces.com/gym/103495/problem/D">D. Pattern Lock</a></h4><blockquote><p>n 行 m 列的点阵图，用一条折线经过所有的点各一次，要求每条线段不经过除端点外的其他点，且形成的角都是锐角 </p><p>关键词：构造 </p></blockquote><p>这题可以分行列的奇偶性来讨论，对于偶数可以有固定的规律进行连接点，奇数则进行特殊处理</p><h3 id="字符串哈希三种方法"><a href="#字符串哈希三种方法" class="headerlink" title="字符串哈希三种方法"></a>字符串哈希三种方法</h3><ol><li>自然溢出hash</li><li>单hash</li><li>双hash</li></ol><h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><h2 id="7-12自主学习"><a href="#7-12自主学习" class="headerlink" title="7.12自主学习"></a>7.12自主学习</h2><blockquote><p>洛谷题单字符串（kmp）</p><p>Manacher算法</p><p> Codeforces Round #806 (Div. 4) </p></blockquote><h3 id="洛谷题单字符串（kmp）"><a href="#洛谷题单字符串（kmp）" class="headerlink" title="洛谷题单字符串（kmp）"></a>洛谷题单字符串（kmp）</h3><h4 id="P4391-BOI2009-Radio-Transmission-无线传输"><a href="#P4391-BOI2009-Radio-Transmission-无线传输" class="headerlink" title="P4391 [BOI2009]Radio Transmission 无线传输"></a><a href="https://www.luogu.com.cn/problem/P4391">P4391 [BOI2009]Radio Transmission 无线传输</a></h4><p>这题为了找最小循环字串，可以引用kmp中求niext数组的思想， 通过ne[n]，找到最短后缀，然后n - ne[n]得出结果</p><h4 id="P3435-POI2006-OKR-Periods-of-Words"><a href="#P3435-POI2006-OKR-Periods-of-Words" class="headerlink" title="P3435 [POI2006] OKR-Periods of Words"></a><a href="https://www.luogu.com.cn/problem/P3435">P3435 [POI2006] OKR-Periods of Words</a></h4><p>找最大周期可以通过next数组，寻找每一位置最前面的适配位置，因为越前面，周期最大</p><h4 id="P4824-USACO15FEB-Censoring-S"><a href="#P4824-USACO15FEB-Censoring-S" class="headerlink" title="P4824 [USACO15FEB] Censoring S"></a><a href="https://www.luogu.com.cn/problem/P4824">P4824 [USACO15FEB] Censoring S</a></h4><p>从字符串中不断删除模式串，可以在kmp算法中增加栈的运用，每次删除完模式串，可以继续比较删除的两边连接之后会不会形成新的模式串</p><h4 id="P2375-NOI2014-动物园"><a href="#P2375-NOI2014-动物园" class="headerlink" title="P2375 [NOI2014] 动物园"></a><a href="https://www.luogu.com.cn/problem/P2375">P2375 [NOI2014] 动物园</a></h4><p>要找每个子字符串的不重复相等前后缀，可以用个num数组记录每个next数组跳到0需要多少步，这样只要每次找前一半的num为多少即可</p><h3 id="Codeforces-Round-806-Div-4"><a href="#Codeforces-Round-806-Div-4" class="headerlink" title="Codeforces Round #806 (Div. 4)"></a><a href="https://codeforces.com/contest/1703">Codeforces Round #806 (Div. 4)</a></h3><p>ABCDE挺好做的，F题前缀和卡住了，G没时间，后来补题补完了，只是要注意用坏钥匙之后如果二进制 &gt;&gt; 超过32，就可以结束循环，不然会tle</p><h2 id="7-13自主学习"><a href="#7-13自主学习" class="headerlink" title="7.13自主学习"></a>7.13自主学习</h2><blockquote><p>Codeforces Round #806 (Div. 4) <strong>FG题补题</strong>（见昨天）</p><p>Manacher题目</p><p>Trie树</p></blockquote><h3 id="Manacher题目"><a href="#Manacher题目" class="headerlink" title="Manacher题目"></a>Manacher题目</h3><p><a href="https://www.luogu.com.cn/problem/P4555">P4555 [国家集训队]最长双回文串</a></p><p>这题需要在维护p数组的同时维护一下 l [ ] , r [ ] , l [ ] 为以当前 i 为左端点最长的回文串，r [ ] 为以当前 i 为右端点最长的回文串，然后以 ‘ # ’ 为断电，选择最长的双回文串</p><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><h4 id="P3879-TJOI2010-阅读理解"><a href="#P3879-TJOI2010-阅读理解" class="headerlink" title="P3879 [TJOI2010] 阅读理解"></a><a href="https://www.luogu.com.cn/problem/P3879">P3879 [TJOI2010] 阅读理解</a></h4><p>这题用个trie树板子把文章的单词存储起来，并且用bitset维护出现的文章序号</p><h2 id="7-15自主学习"><a href="#7-15自主学习" class="headerlink" title="7.15自主学习"></a>7.15自主学习</h2><blockquote><p>ac自动机</p></blockquote><h4 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h4><p>模板（简单，加强，二次加强），二次加强结合了拓扑排序优化了query</p><h2 id="7-17自主学习"><a href="#7-17自主学习" class="headerlink" title="7.17自主学习"></a>7.17自主学习</h2><blockquote><p>搜索题目</p></blockquote><h4 id="搜索题目（引水入城）"><a href="#搜索题目（引水入城）" class="headerlink" title="搜索题目（引水入城）"></a><a href="https://www.luogu.com.cn/problem/P1514">搜索题目（引水入城）</a></h4><p>这题要验证从一个点搜索到最后一行是一段连续区间，就可以变成区间覆盖问题，只需要dfs第一行每一个点</p>]]></content>
    
    
    <categories>
      
      <category>训练记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>训练记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2022/07/02/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2022/07/02/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> c[a][b];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ ) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ ) &#123;<br>        <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j] + c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预处理逆元求组合数"><a href="#预处理逆元求组合数" class="headerlink" title="预处理逆元求组合数"></a>预处理逆元求组合数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> f[N], inv[N];<br><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(ll a, ll k, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>f[<span class="hljs-number">0</span>] = inv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i ++ ) &#123;<br>    f[i] = f[i<span class="hljs-number">-1</span>] * i % mod;<br>    inv[i] = inv[i<span class="hljs-number">-1</span>] * <span class="hljs-built_in">qmi</span>(i,mod<span class="hljs-number">-2</span>,mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lucas定理求组合数"><a href="#Lucas定理求组合数" class="headerlink" title="Lucas定理求组合数"></a>Lucas定理求组合数</h2><p>若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：<br>    C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)ll x, </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (ll i = a,j = <span class="hljs-number">1</span>; j &lt;=b; i --, j ++ ) &#123;<br>        x = x * i % p;<br>        y = y * j % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">qmi</span>(y,mod<span class="hljs-number">-2</span>,mod);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">lucas</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b,p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a%p,b%p,p) * <span class="hljs-built_in">lucas</span>(a/p,b/p/p) % p;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆元</title>
    <link href="/2022/06/25/%E9%80%86%E5%85%83/"/>
    <url>/2022/06/25/%E9%80%86%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><p>若a*x≡1(mod b) ,a,b互质，则称x为a的逆元。</p><p>A&#x2F;B %p&#x3D;A*inv(B) %p ,inv(B)为B的逆元。</p><p><strong>如果b过大，可能会爆精度，且除法不满足同于拆分定理。</strong></p><p>求逆元的三种方法：</p><ul><li>费马小定理</li><li>扩展欧几里得求逆元</li><li>逆元线性筛</li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>$$<br>a^{m-1} \equiv 1(mod m) \Rightarrow a *a^{m-2} \equiv 1(mod m)\Rightarrow a^{m-2} \equiv {1 \over a} (modm)<br>$$</p><p>所以a^(m-2)就是a的逆元了。</p><p>计算复杂度为o(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//快速幂</span><br><span class="hljs-function">ll <span class="hljs-title">quickpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    ll res = <span class="hljs-number">1</span>;<br>    a %= mod;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = (res * a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (a * a) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//求逆元</span><br><span class="hljs-function">ll <span class="hljs-title">inv</span> <span class="hljs-params">(ll a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickpow</span>(a,mod<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p>通过ax+my&#x3D;1，来求x，x为逆元。</p><p>a，m互质。</p><p>复杂度o(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">ex_gcd</span>(b,a%b,x,y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mod_reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d, x, y;<br>    d = <span class="hljs-built_in">ex_gcd</span>(a,b,x,y);<br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> (x % b + b) % b;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="逆元线性筛"><a href="#逆元线性筛" class="headerlink" title="逆元线性筛"></a>逆元线性筛</h2><p>求1，2，3……N的逆元。</p><p>复杂度o(N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e7</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10005</span>;<br><span class="hljs-type">int</span> inv[maxn];<br>inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10000</span>; i ++ ) &#123;<br>    inv[i] = inv[mod%i] * (mod - mod / i) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉函数</title>
    <link href="/2022/06/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <url>/2022/06/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> prime[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> euler[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">()</span> </span>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            prime[cnt++] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j ++ ) &#123;<br>            <span class="hljs-type">int</span> t = prime[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>                euler[t] = euler[j] * prime[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[j] * (prime[i] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数判定</title>
    <link href="/2022/06/01/%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/"/>
    <url>/2022/06/01/%E8%B4%A8%E6%95%B0%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="质数判定"><a href="#质数判定" class="headerlink" title="质数判定"></a>质数判定</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> prime[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) prime[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始化所有数为素数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">if</span>(prime[i]) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i) prime[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> prime[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] * i &lt;= n; j ++) &#123;<br>            st[prime[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树基础</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树基础"><a href="#线段树基础" class="headerlink" title="线段树基础"></a>线段树基础</h1><blockquote><p>线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)).</p><p>线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。</p></blockquote><p>由此看出，用线段树统计的东西，必须符合<strong>区间加法</strong>，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 </p><blockquote><p>符合区间加法的例子：<br>数字之和——总数字之和 &#x3D; 左区间数字之和 + 右区间数字之和<br>最大公因数(GCD)——总GCD &#x3D; gcd( 左区间GCD , 右区间GCD );<br>最大值——总最大值&#x3D;max(左区间最大值，右区间最大值)<br>不符合区间加法的例子：<br>众数——只知道左右区间的众数，没法求总区间的众数<br>01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零</p></blockquote><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>以维护数列区间和的线段树为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> itn;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug puts(<span class="hljs-string">&quot;----------&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem(a,b) memset((a),(b),sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FI first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SE second</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br>ll n, m;<br>ll a[N];<br>ll sum[N&lt;&lt;<span class="hljs-number">2</span>], lazy[N&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">/*****************read()*******************/</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">ls</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br><span class="hljs-keyword">return</span> rt &lt;&lt; <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">rs</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br><span class="hljs-keyword">return</span> rt &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll rt)</span> </span>&#123;<br>sum[rt] = sum[<span class="hljs-built_in">ls</span>(rt)] + sum[<span class="hljs-built_in">rs</span>(rt)];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll ln, ll rn, ll rt)</span> </span>&#123;<br>lazy[<span class="hljs-built_in">ls</span>(rt)] += lazy[rt];<br>lazy[<span class="hljs-built_in">rs</span>(rt)] += lazy[rt];<br>sum[<span class="hljs-built_in">ls</span>(rt)] += lazy[rt] * ln;<br>sum[<span class="hljs-built_in">rs</span>(rt)] += lazy[rt] * rn;<br>lazy[rt] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll l, ll r, ll rt)</span> </span>&#123;<br>lazy[rt] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>sum[rt] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(l,mid,<span class="hljs-built_in">ls</span>(rt));<br><span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt));<br><span class="hljs-built_in">push_up</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll rt, ll k)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;<br>sum[rt] += k * (r - l + <span class="hljs-number">1</span>);<br>lazy[rt] += k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">push_down</span>(mid-l+<span class="hljs-number">1</span>,r-mid,rt);<br><span class="hljs-keyword">if</span> (L &lt;= mid) <span class="hljs-built_in">update</span>(L,R,l,mid,<span class="hljs-built_in">ls</span>(rt),k);<br><span class="hljs-keyword">if</span> (R &gt; mid) <span class="hljs-built_in">update</span>(L,R,mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt),k);<br><span class="hljs-built_in">push_up</span>(rt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">query</span><span class="hljs-params">(ll L, ll R, ll l, ll r, ll rt)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="hljs-keyword">return</span> sum[rt];<br>ll ans = <span class="hljs-number">0</span>, mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">push_down</span>(mid-l+<span class="hljs-number">1</span>,r-mid,rt);<br><span class="hljs-keyword">if</span> (L &lt;= mid) ans += <span class="hljs-built_in">query</span>(L,R,l,mid,<span class="hljs-built_in">ls</span>(rt));<br><span class="hljs-keyword">if</span> (R &gt; mid) ans += <span class="hljs-built_in">query</span>(L,R,mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(rt));<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) a[i] = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span> (m--) &#123;<br>ll op, x, y, k;<br>op = <span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">switch</span> (op) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>(), k = <span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">update</span>(x,y,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,k);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();<br>cout &lt;&lt; <span class="hljs-built_in">query</span>(x,y,<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>非递归代码简单，速度快，但是如果要区间修改的话，代码会复杂。</p><ul><li><strong>原数组下标</strong>，是指，需要维护统计信息（比如区间求和）的数组的下标，这里都默认下标从1开始（一般用A数组表示）</li><li><strong>线段树下标</strong>，是指，加入线段树中某个位置的下标，比如，原数组中的第一个数，一般会加入到线段树中的第二个位置，<br>为什么要这么做，后面会讲。</li><li><strong>存储下标</strong>，是指该元素所在的叶节点的编号，即实际存储的位置。</li></ul><p><strong>原数组下标+1&#x3D;线段树下标</strong></p><p><strong>线段树下标+N-1&#x3D;存储下标</strong></p><p>故得到：<strong>原数组下标+N&#x3D;存储下标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100007</span>;<br><span class="hljs-type">int</span> sum[maxn&lt;&lt;<span class="hljs-number">2</span>],add[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[maxn],n,N;<span class="hljs-comment">//m为扩充元素个数</span><br><br><span class="hljs-comment">//建树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    N=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(N&lt;n+<span class="hljs-number">2</span>) N&lt;&lt;=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[N+i]=a[i];<span class="hljs-comment">//原数组下标+N=存储下标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        sum[i]=sum[i&lt;&lt;<span class="hljs-number">1</span>]+sum[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>        add[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//清空懒惰标记</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//单点修改,a[i]+=c</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N+x;i;i&gt;&gt;=<span class="hljs-number">1</span>) sum[i]+=c;<span class="hljs-comment">//更新当前节点和父节点</span><br>&#125;<br><br><span class="hljs-comment">//单点修改完后的区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//s和t都是l~r区间左右两端的节点,在s和t父节点相同时退出</span><br>        <span class="hljs-keyword">if</span>(~s&amp;<span class="hljs-number">1</span>) ans+=sum[s^<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>) ans+=sum[t^<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-type">int</span> s,t,ln=<span class="hljs-number">0</span>,rn=<span class="hljs-number">0</span>,x=<span class="hljs-number">1</span>;<span class="hljs-comment">//ln为s经过的节点数，rn为t经过的节点数，x为本层每个节点包含了几个数</span><br>    <span class="hljs-keyword">for</span>(s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>,x&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//更新sum</span><br>        sum[s]+=c*ln;<br>        sum[t]+=c*rn;<br>        <span class="hljs-comment">//处理add</span><br>        <span class="hljs-keyword">if</span>(~s&amp;<span class="hljs-number">1</span>) add[s^<span class="hljs-number">1</span>]+=c,sum[s^<span class="hljs-number">1</span>]+=c*x,ln+=x;<br>        <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>) add[t^<span class="hljs-number">1</span>]+=c,sum[t^<span class="hljs-number">1</span>]+=c*x,rn+=x;<br>    &#125;<br>    <span class="hljs-comment">//更新上层sum</span><br>    <span class="hljs-keyword">for</span>(;s;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>)&#123;<br>        sum[s]+=c*ln;<br>        sum[t]+=c*rn;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//区间修改完后的区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> s,t,ln=<span class="hljs-number">0</span>,rn=<span class="hljs-number">0</span>,x=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(s=N+l<span class="hljs-number">-1</span>,t=N+r+<span class="hljs-number">1</span>;s^t^<span class="hljs-number">1</span>;s&gt;&gt;=<span class="hljs-number">1</span>,t&gt;&gt;=<span class="hljs-number">1</span>,x&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//根据标记更新</span><br>        <span class="hljs-keyword">if</span>(add[s]) ans+=add[s]*ln;<br>        <span class="hljs-keyword">if</span>(add[t]) ans+=add[t]*rn;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2022/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2022/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在一给定的无向图G&#x3D;(V,E) 中，(u,v)代表连接顶点u与顶点v的边，而w(u,v) 代表此边的权重，若存在T为E的子集且为无循环图，使得w(T) 最小，则此T为G的最小生成树，因为T是由图G产生的。简单来说，就是经过连通图的每一个点，并且保证边权总和最小。</p><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>prim算法利用贪心的思想实现。任意选定一个节点，从该节点出发，每次选择包含该节点的最短路径，直到遍历所有节点。一般用于稠密图</p><blockquote><p> prim算法与Dijkstra算法区别：<br>Dijkstra算法的数组dis[]含义为起点s达到顶点Vi的最短距离。<br>prim算法的数组dis[]含义为顶点Vi与集合S（已经访问的点集）的最短距离 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-comment">//默认0为初始点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//存放边权之和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-number">0</span>&amp;&amp;(t==<span class="hljs-number">-1</span>||dis[j]&lt;dis[t]))&#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&amp;&amp;dis[t]==INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vis[t]=<span class="hljs-number">1</span>;<br>        ans+=d[t];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dis[j]=<span class="hljs-built_in">min</span>(dis[j],g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>kruskal算法利用贪心思想实现的，我们先将所有边权从小到大排列，按照顺序选取每条边，如果这条边的两个端点不属于同一个集合，那么将他们合并，直到所有的点都属于同一个集合为止。合并点集我们需要使用到并查集。一般用于稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> edges &amp;t)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&lt;t.w;<br>    &#125;<br>&#125;edge[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edge,edge+m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a=edge[i].a,b=dege[i].b,w=edge[i].w;<br>        a=<span class="hljs-built_in">find</span>(a),b=<span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            p[b]=a;<br>            ans+=w;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt&lt;n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//无向图不连通，不存在最小生成树</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求最短路</title>
    <link href="/2022/05/01/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/05/01/%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="求最短路"><a href="#求最短路" class="headerlink" title="求最短路"></a>求最短路</h1><p>首先先了解一下最短路的框架。</p><blockquote><p><strong>单源最短路：</strong> 求一个点到其他点的最短路<br><strong>多源最短路：</strong> 求任意两个点的最短路</p></blockquote><p>稠密图用邻接矩阵存，稀疏图用<a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&spm=1001.2101.3001.7020">邻接表</a>存储。</p><blockquote><p><strong>稠密图：</strong> m 和 n2 一个级别<br><strong>稀疏图：</strong> m 和 n 一个级别</p></blockquote><h2 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h2><p>floyd<strong>优点</strong>在于代码实现简单。缺点在于<strong>复杂度</strong>为o(n^3)，不能用于大规模数据，多源最短路算法。</p><p>floyd算法可以算带负权的，但是不能算负权回路。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(i==j) d[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> d[i][j]=INF;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//floyd</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//d[a][b]即为a到b的最短路</span><br></code></pre></td></tr></table></figure><h2 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h2><p>dijkstra算法只能用于计算边权都为正的图，是单源最短路算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//邻接矩阵</span><br><br><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dis[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)   <span class="hljs-comment">// 在没有确定最短路中的所有点找出距离最短的那个点 t </span><br>   <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]))<br>    t=j;<br>st[t]=<span class="hljs-literal">true</span>; <span class="hljs-comment">// 代表 t 这个点已经确定最短路了</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++) <span class="hljs-comment">// 用 t 更新其他点的最短距离 </span><br> dis[j] = <span class="hljs-built_in">min</span>(dis[j],dis[t]+g[t][j]);<br> &#125; <br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆优化的dijkstra算法"><a href="#堆优化的dijkstra算法" class="headerlink" title="堆优化的dijkstra算法"></a>堆优化的dijkstra算法</h2><p>朴素版用来计算稠密图，用邻接矩阵存储。而堆优化版用来计算稀疏图，用邻接表存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-comment">//求1号点到n号点的最短距离，如果不存在，返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//first距离  second节点</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-type">int</span> dist=t.first,ver=t.second;<br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(dis[j]&gt;dist+w[i])&#123;<br>                dis[j]=dist+w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dis[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ford算法"><a href="#ford算法" class="headerlink" title="ford算法"></a>ford算法</h2><p>ford算法可以用于对于有边数限制要求的最短路，比如求从1号到n号最多经过k条边的最短距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> dis[N],backup[N]; <span class="hljs-comment">//backup数组为上次</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edges</span><br>&#123;<br>   <span class="hljs-type">int</span> a,b,w; <span class="hljs-comment">// a-&gt;b权值为w的边 </span><br>&#125;edge[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) <br>&#123;<br><span class="hljs-built_in">memcpy</span>(backup,dis,<span class="hljs-keyword">sizeof</span> dis); <span class="hljs-comment">//备份</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;m; j++)   <span class="hljs-comment">// 枚举所有边 </span><br>&#123;<br>   <span class="hljs-type">int</span> a = edge[j].a, b = edge[j].b, w=edge[j].w;<br>   dis[b] = <span class="hljs-built_in">min</span>(dis[b],backup[a]+w); <span class="hljs-comment">// 用备份更新 </span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dis[n] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><p>spfa可以计算没有负环的图，可以有负权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dis[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])<br>            &#123;<br>                dis[j] = dis[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa判断有无负环"><a href="#spfa判断有无负环" class="headerlink" title="spfa判断有无负环"></a>spfa判断有无负环</h2><p>如果经过一个环后距离为负，则为负环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dis[N], cnt[N];        <span class="hljs-comment">// dis[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<span class="hljs-comment">//所有节点入队</span><br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])<br>            &#123;<br>                dis[j] = dis[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 说明存在负环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不存在负环</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/2022/04/29/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2022/04/29/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>​                    </p><p>​</p><h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><p>二分图判定有两点：</p><ol><li>图为连通图。</li><li>可以分为两个不同的点集。</li></ol><p>一般使用染色法来进行判定，如果每条边两个端点的颜色不同，则说明是二分图。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-comment">//判定</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> color)</span></span>&#123;<br>    col[x]=color;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> k=e[i];<br>        <span class="hljs-keyword">if</span>(col[k]==col[x])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不是二分图</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!col[k])&#123;<br>            <span class="hljs-built_in">dfs</span>(k,-color);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> k=e[i];<br>        <span class="hljs-keyword">if</span>(!vis[k])&#123;<br>            vis[k]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[k]==<span class="hljs-number">0</span>||<span class="hljs-built_in">find</span>(match[k]))&#123;<span class="hljs-comment">//如果没匹配过或者有还有其他匹配</span><br>                match[k]=x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>st表</title>
    <link href="/2022/04/27/st%E8%A1%A8/"/>
    <url>/2022/04/27/st%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="st表"><a href="#st表" class="headerlink" title="st表"></a><strong>st表</strong></h1><p>什么是st表， st表是一种基于倍增思想，用于解决<strong>可重复贡献问题</strong>的<strong>数据结构</strong>。 st表应用最广泛的领域便是解决RMQ问题：给定n个数，m个询问，对于每个询问，需要回答区间[ l , r ] 中的最大值或最小值(可以采用两个数组同时进行处理)。 除 RMQ 以外，还有其它的“<strong>可重复贡献问题</strong>”。例如“<strong>区间按位和”</strong>、“<strong>区间按位或</strong>”、“<strong>区间 gcd</strong>”，st 表都能高效地解决。 </p><h2 id="st表板子："><a href="#st表板子：" class="headerlink" title="st表板子："></a>st表板子：</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[N][<span class="hljs-number">25</span>];<br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    mn[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        mn[i]=((i&amp;(i<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>)?mn[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>:mn[i<span class="hljs-number">-1</span>];<br>        st[i][<span class="hljs-number">0</span>]=a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=mn[n];j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>            st[i][j]=<span class="hljs-built_in">max</span>(st[i][j<span class="hljs-number">-1</span>],st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<span class="hljs-comment">//这里是求区间最大值</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//查询最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmq_max</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> k=mn[r-k+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(st[l][k],st[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑序</title>
    <link href="/2022/04/26/%E6%8B%93%E6%89%91%E5%BA%8F/"/>
    <url>/2022/04/26/%E6%8B%93%E6%89%91%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h1><p> 在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。如果有环，则不可能有拓扑序。                                                                                     </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt;q;<br>vector&lt;<span class="hljs-type">int</span>&gt;e[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;ans;<br><span class="hljs-comment">//入度为0的点入队</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-type">int</span> k=q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    ans.<span class="hljs-built_in">push_back</span>(k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;e[p].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> y=e[k][i];<br>        in[y]--;<br>        <span class="hljs-keyword">if</span>(in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果ans的长度为n，则说明这个图具有拓扑序列，否则不具有。</p><p>并且如果需要按照字典序输出字典序最大的拓扑序，可以室友priority_queue（优先队列）即可。</p>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lca</title>
    <link href="/2022/04/25/lca/"/>
    <url>/2022/04/25/lca/</url>
    
    <content type="html"><![CDATA[<h1 id="LCA算法"><a href="#LCA算法" class="headerlink" title="LCA算法"></a>LCA算法</h1><p>LCA（Least Common Ancestors），即最近公共祖先，指对于有根树 T 的两个结点 u 、v ，最近公共祖先 LCA(T,u,v) 表示一个结点 x, 满足 x 是 u、v 的祖先且 x 的深度尽可能大。</p><p>求解lca的四种方法：</p><ol><li><p>用倍增法求解，预处理复杂度是 O(nlogn)O(nlog⁡n) ,每次询问的复杂度是 O(logn)O(log⁡n), 属于在线解法。</p></li><li><p>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)O(n+nlog⁡n) ，每次询问的复杂度为 O(1)O(1)， 也是在线算法。</p></li><li><p>采用Tarjan算法求解，复杂度 O(α(n)+Q)O(α(n)+Q) ，属于离线算法。</p></li><li><p>利用树链剖分求解，复杂度预处理O(n)O(n) ，单次查询 O(logn)O(log⁡n) ，属于在线算法。</p></li></ol><p><strong>当然，第四种树链剖分表示不会，这里就不展开了。</strong></p><h2 id="倍增法求lca"><a href="#倍增法求lca" class="headerlink" title="倍增法求lca"></a>倍增法求lca</h2><p> 最常用，也是最简单的算法，实质就是直接对暴力使用倍增优化将复杂度降低达到需求。 </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存每个节点连接的节点</span><br>fa[][];<br>dep[];<br>vis[];<br><span class="hljs-comment">//dfs预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x];i++) fa[x][i]=fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(vis[e[i]]) <span class="hljs-keyword">continue</span>;<br>        vis[e[i]]=<span class="hljs-literal">true</span>;<br>        dep[e[i]]=dep[x]+<span class="hljs-number">1</span>;<br>        fa[e[i]][<span class="hljs-number">0</span>]=x;<br>        <span class="hljs-built_in">dfs</span>(e[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//lca</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[u]&lt;dep[v]) <span class="hljs-built_in">swap</span>(u,v);<br>    <span class="hljs-type">int</span> k=<span class="hljs-built_in">log2</span>(dep[u]-dep[v]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(dep[fa[u][i]]&gt;=dep[v]) u=dp[u][i];<span class="hljs-comment">//跳到同一高度</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> u;<br>    k=<span class="hljs-built_in">log2</span>(dep[u]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<span class="hljs-comment">//跳到lca的下一层</span><br>        <span class="hljs-keyword">if</span>(fa[u][i]==fa[v][i]) <span class="hljs-keyword">continue</span>;<br>        u=fa[u][i];<br>        v=fa[v][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<span class="hljs-comment">//返回lca下一层的父节点，即lca节点</span><br>&#125;<br><br><span class="hljs-comment">//初始化</span><br>dep[s]=<span class="hljs-number">1</span>;<br>vis[s]=<span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><h2 id="欧拉序-st表"><a href="#欧拉序-st表" class="headerlink" title="欧拉序+st表"></a>欧拉序+st表</h2><p>学了st表，建议用这个，这个套用一个st表代码实现会比较方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星存储</span><br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> dep)</span></span>&#123;<br>first[u]=++tot;<span class="hljs-comment">//每个节点第一次出现在欧拉序上的位置</span><br>ver[tot]=u;<span class="hljs-comment">//欧拉序</span><br>deep[u]=dep;每个节点的深度<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-keyword">if</span>(!first[j])&#123;<br><span class="hljs-built_in">dfs</span>(j,dep+<span class="hljs-number">1</span>);<br>ver[++tot]=u;<span class="hljs-comment">//每次dfs之后都要返回原来的u节点</span><br>deep[u]=dep;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>mn[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;<br>mn[i]=((i&amp;(i<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>?mn[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>:mn[i<span class="hljs-number">-1</span>];<br>st[i][<span class="hljs-number">0</span>]=ver[i];<span class="hljs-comment">//st表存储欧拉序上的节点</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=mn[tot];j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=tot;i++)&#123;<br><span class="hljs-keyword">if</span>(deep[st[i][j<span class="hljs-number">-1</span>]]&lt;deep[st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]])&#123;<span class="hljs-comment">//按照深度大小dp</span><br>st[i][j]=st[i][j<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">else</span> st[i][j]=st[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查询</span><br><span class="hljs-type">int</span> u,v;<br>u=first[u];<br>v=first[v];<br><span class="hljs-keyword">if</span>(u&gt;v) <span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-type">int</span> k=mn[v-u+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(deep[st[u][k]]&lt;deep[st[v-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]])&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, st[u][k]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, st[v-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的直径</title>
    <link href="/2022/04/25/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/04/25/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p>树的直径就是树上最远两点的距离。这里介绍复杂度O(n) 的解法，即两次dfs（或者bfs）来求取直径。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>从任意一点P出发，通过DFS寻找离它最远的点Q。</li><li>再次从点Q出发，通过DFS寻找离它最远的W。</li><li>直径即为WQ。</li></ol><p> <u>该算法的优点是，可以得知整条直径上的所有节点（尤其得知了端点），便于其他的操作。</u> </p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs搜索距离st最远的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> t=edge[st][i];<span class="hljs-comment">//t为连接st的节点</span><br>        <span class="hljs-keyword">if</span>(!vis[t])&#123;<br>            vis[t]=<span class="hljs-number">1</span>;<br>            dis[t]=dis[st]+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的重心</title>
    <link href="/2022/04/24/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    <url>/2022/04/24/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><p> <strong>树的重心又叫树的质心</strong>：对于一颗n个节点的无根树，找到一个点，使得把树变成以该节点为根的有根树时，最大子树的节点数最少。换句话说，删除这个节点后最大连通块（一定是树）的节点数最少。 </p><h2 id="树的重心性质"><a href="#树的重心性质" class="headerlink" title="树的重心性质"></a>树的重心性质</h2><ol><li>树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。</li><li>把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。</li><li>一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。</li><li>一棵树最多有两个重心，且相邻。</li></ol><p><strong>考点</strong>：树形dp+dfs</p><h3 id="dfs部分"><a href="#dfs部分" class="headerlink" title="dfs部分"></a>dfs部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录u节点的最大子节点数</span><br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录u为根的节点数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<span class="hljs-comment">//链式前向星存每个节点连接的节点</span><br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-keyword">if</span>(vis[j]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> s=<span class="hljs-built_in">dfs</span>(j);<br>        size=<span class="hljs-built_in">max</span>(size,s);<br>        sum+=s;<br>    &#125;<br>    ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">max</span>(size,n-sum));<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树真是个<del>可爱</del>的东西呢（我要烦死了）。                                                                                </p><p>​                                      </p><h2 id="先序中序求后序层次遍历"><a href="#先序中序求后序层次遍历" class="headerlink" title="先序中序求后序层次遍历"></a>先序中序求后序层次遍历</h2><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-type">int</span> l,r;<br>&#125;tree[N];<br><span class="hljs-type">int</span> in[N],post[N];<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mp;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> prel,<span class="hljs-type">int</span> prer)</span></span>&#123;<br><span class="hljs-keyword">if</span>(inl&gt;inr||prel&gt;prer) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> rt=pre[prel];<br><span class="hljs-type">int</span> index=mp[rt];<br><span class="hljs-type">int</span> pos=++p;<br><span class="hljs-type">int</span> l=index-inl;<br>t[pos].data=rt;<br>t[pos].l=<span class="hljs-built_in">build</span>(inl,index<span class="hljs-number">-1</span>,prel+<span class="hljs-number">1</span>,prel+l);<br>t[pos].r=<span class="hljs-built_in">build</span>(index+<span class="hljs-number">1</span>,inr,prel+l+<span class="hljs-number">1</span>,prer);<br><span class="hljs-keyword">return</span> pos;<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(t[u].left!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(t[u].left);<br>    <span class="hljs-keyword">if</span>(t[u].right!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(t[u].right);<br>    cout&lt;&lt;t[u].data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//层次遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt;q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;tree[u].data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; <br><span class="hljs-keyword">if</span>(tree[u].l!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(tree[u].l);<br><span class="hljs-keyword">if</span>(tree[u].r!=<span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(tree[u].r);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="后序中序求先序层次遍历"><a href="#后序中序求先序层次遍历" class="headerlink" title="后序中序求先序层次遍历"></a>后序中序求先序层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> postl,<span class="hljs-type">int</span> postr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(inl&gt;inr||postl&gt;postr) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//结束</span><br>    <span class="hljs-type">int</span> now=post[postr];<br>    <span class="hljs-type">int</span> index=mp[now];<br>    <span class="hljs-type">int</span> pos=++p;<br>    <span class="hljs-type">int</span> len=index-inl;<br>    t[pos].data=now;<br>    t[pos].left=<span class="hljs-built_in">build</span>(inl,index<span class="hljs-number">-1</span>,postl,prel+len<span class="hljs-number">-1</span>);<br>    t[pos].right=<span class="hljs-built_in">build</span>(index+<span class="hljs-number">1</span>,inr,post+len,postr<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> pos;<span class="hljs-comment">//返回当前指针位置</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组进阶</title>
    <link href="/2022/04/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/04/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组进阶"><a href="#树状数组进阶" class="headerlink" title="树状数组进阶"></a>树状数组进阶</h1><p>我们可以使用<del>可爱的</del>树状数组实现什么呢？</p><h2 id="求逆序对"><a href="#求逆序对" class="headerlink" title="求逆序对"></a>求逆序对</h2><p><strong>树状数组+离散化</strong></p><p>假设此时已经将a[]离散化处理成了b[]，最后的ans即为逆序对个数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]++;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        res+=c[x];<br>            x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//离散化比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a[x]==a[y]) <span class="hljs-keyword">return</span> x&gt;y;<br>    <span class="hljs-keyword">return</span> a[x]&gt;a[y];<br>&#125;<br><br><span class="hljs-comment">//a的逆序对个数为</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-built_in">update</span>(d[i]);<br>    ans+=<span class="hljs-built_in">getsum</span>(d[i]<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求区间最大值"><a href="#求区间最大值" class="headerlink" title="求区间最大值"></a>求区间最大值</h2><p><strong>单点更新+区间查询</strong></p><p>单点更新复杂度为O(logn*logn)</p><p>区间查询复杂度为O(logn*logn)</p><p>运用分块思想，将区间l~r通过lowbit分成多块，再将每块的最大值合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]=a[x];<span class="hljs-comment">//每次先更新自身</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">lowbit</span>(x);i&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>            c[x]=<span class="hljs-built_in">max</span>(c[x],c[x<span class="hljs-number">-1</span>]);<br>            x+=<span class="hljs-built_in">lowbit</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmax</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(r&gt;=l)&#123;<br>        ans=<span class="hljs-built_in">max</span>(ans,a[r]);<br>        r--;<br>        <span class="hljs-keyword">for</span>(r;<span class="hljs-built_in">lowbit</span>(r)&gt;=l;r-=<span class="hljs-built_in">lowbit</span>(r))&#123;<br>            ans=<span class="hljs-built_in">max</span>(ans,h[r]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本操作进阶版"><a href="#基本操作进阶版" class="headerlink" title="基本操作进阶版"></a>基本操作进阶版</h2><p>继树状数组基础里面的<strong>单点修改+区间查询</strong>，我们可以使用差分，进而实现<strong>区间修改+单点查询</strong></p><h2 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改+单点查询"></a>区间修改+单点查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        c[x]+=y;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>        sum+=c[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">update</span>(i,a[i]-a[i<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-built_in">update</span>(l,k);<br><span class="hljs-built_in">update</span>(r+<span class="hljs-number">1</span>,-k);<br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">query</span>(x);<br></code></pre></td></tr></table></figure><h2 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改+区间查询"></a>区间修改+区间查询</h2><p>区间查询和上面的单点查询有些区别，需要两个数组c[],c1[]。假设相邻两数a[i],a[i-1]的差分为bi，则c维护bi，c1维护i*bi</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> *p,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        p[x]+=y;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,temp=x;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>        sum+=(temp)*c[x]-c1[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">update</span>(c,i,a[i]-b);<br>    <span class="hljs-built_in">update</span>(c1,i,(i<span class="hljs-number">-1</span>)*(a[i]-b);<br>   b=a[i];<br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-built_in">update</span>(c,l,k);<br><span class="hljs-built_in">update</span>(c,r+<span class="hljs-number">1</span>,-k);<br><span class="hljs-built_in">update</span>(c1,l,(l<span class="hljs-number">-1</span>)*k);<br><span class="hljs-built_in">update</span>(c1,r+<span class="hljs-number">1</span>,-r*k);<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-built_in">query</span>(r)-<span class="hljs-built_in">query</span>(l<span class="hljs-number">-1</span>);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三元上升子序列</title>
    <link href="/2022/04/19/%E4%B8%89%E5%85%83%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/04/19/%E4%B8%89%E5%85%83%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="三元上升子序列"><a href="#三元上升子序列" class="headerlink" title="三元上升子序列"></a><a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Erwin 最近对一种叫 <code>thair</code> 的东西巨感兴趣。。。</p><p>在含有 n 个整数的序列 a1,a2,,…,an中，三个数被称作<code>thair</code>当且仅当 i&lt;j&lt;k<em>i</em>&lt;<em>j</em>&lt;<em>k</em> 且 a_i&lt;a_j&lt;a_k<em>a**i</em>&lt;<em>a**j</em>&lt;<em>a**k</em>。</p><p>求一个序列中 <code>thair</code> 的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>开始一行一个正整数 n<em>n</em>,</p><p>以后一行 n<em>n</em> 个整数 a_1,a_2,\ldots,a_n<em>a</em>1,<em>a</em>2,…,<em>a**n</em>。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p> 一行一个整数表示 <code>thair</code> 的个数。 </p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入#1"></a>输入#1</h3><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出#1</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>输入#2</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出#7</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="说明-x2F-提示"><a href="#说明-x2F-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><h4 id="样例2-解释"><a href="#样例2-解释" class="headerlink" title="样例2 解释"></a>样例2 解释</h4><p>7个 <code>thair</code> 分别是：</p><ul><li>1 2 3</li><li>1 2 4</li><li>1 2 3</li><li>1 2 4</li><li>1 3 4</li><li>2 3 4</li><li>2 3 4</li></ul><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30%30% 的数据 保证 n\le100<em>n</em>≤100；</li><li>对于 60%60% 的数据 保证 n\le2000<em>n</em>≤2000；</li><li>对于 100%100% 的数据 保证 1 \leq n\le3\times10^41≤<em>n</em>≤3×104，0\le a_i\lt 10^50≤<em>a**i</em>&lt;105。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先这题的思路可以枚举中间数j，然后再求j左边比它小的数的个数，以及j右边比它大的数的个数，两数相乘即为中间数j对答案的贡献值，枚举的复杂度为O(n)。</p><p>那么，为什么这题需要树状数组呢，树状数组复杂度为O(logn)，每次枚举j的时候，都要求左边以及右边的前缀和，由于无规则排列，光前缀和没法实现，那么便需要树状数组加上离散化，动态求解前缀和。</p><p>拥有了树状数组的基础知识之后，就来讲一下离散化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>    cin&gt;&gt;a[i];<br>    a1[i]=a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+n);<br>m=<span class="hljs-built_in">unique</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+n)-(a1+<span class="hljs-number">1</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">Q</span><span class="hljs-params">(ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(a1+<span class="hljs-number">1</span>,a1+<span class="hljs-number">1</span>+m,val)-a1;<br>&#125;<br></code></pre></td></tr></table></figure><p>a1为离散化数组，将a1数组重排列之后去重，m即离散化数组的长度。函数Q返回val离散化的值。这样一来，权值树状数组便诞生了。</p><p>我们再创建一个序列，记录每个数字出现的次数。便于树状数组维护其前缀和。</p><p>接下来就是求解j左右个数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>    <span class="hljs-built_in">update</span>(<span class="hljs-built_in">Q</span>(a[i]),<span class="hljs-number">1</span>);<br>    l[i]=<span class="hljs-built_in">getsum</span>(<span class="hljs-built_in">Q</span>(a[i])<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-keyword">for</span>(i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>&#123;<br>    <span class="hljs-built_in">update</span>(<span class="hljs-built_in">Q</span>(a[i]),<span class="hljs-number">1</span>);<br>    r[i]=n-i-(<span class="hljs-built_in">getsum</span>(<span class="hljs-built_in">Q</span>(a[i]))<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e4</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a[N],s[N],c[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l[N],r[N];<br><br><span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll val)</span></span>&#123;<br><span class="hljs-keyword">while</span>(x&lt;N) c[x]+=val,x+=<span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>) ans+=c[x],x-=<span class="hljs-built_in">lowbit</span>(x);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">q</span><span class="hljs-params">(ll val)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+m,val)-s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>s[i]=a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n);<br>m=<span class="hljs-built_in">unique</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n)-s<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">q</span>(a[i]),<span class="hljs-number">1</span>);<br>l[i]=<span class="hljs-built_in">query</span>(<span class="hljs-built_in">q</span>(a[i])<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> c);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">q</span>(a[i]),<span class="hljs-number">1</span>);<br>r[i]=n-i-(<span class="hljs-built_in">query</span>(<span class="hljs-built_in">q</span>(a[i]))<span class="hljs-number">-1</span>);<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>ans+=l[i]*r[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组基础</title>
    <link href="/2022/04/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/19/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组基础"><a href="#树状数组基础" class="headerlink" title="树状数组基础"></a>树状数组基础</h1><p>树状数组是一个查询和修改复杂度都为log(n)的数据结构。 </p><p>学习树状数组，需要习惯使用二进制的思维。树状数组的更新和查询过程类似一颗<strong>二叉树</strong>。树状数组需要长度n，一个初始的数组（我们记为a[]，以及一个新的数组（我们记为c[]，这里的思路有点类似于前缀和）。</p><h2 id="结构根本"><a href="#结构根本" class="headerlink" title="结构根本"></a>结构根本</h2><ol><li><code>更新</code>过程时，每个根节点相当于他的子节点加上子节点的最低位1。 (101 + 1 -&gt;110, 110 + 10 -&gt; 1000, 1000 + 1000 -&gt; 10000) </li><li><code>查询</code>过程时，每个根节点相当于去掉了根节点最低位1。 (1111 - 1 -&gt; 1110, 1110  - 10 -&gt; 1100, 1100 - 100 -&gt; 1000)</li></ol><p>那么！树状数组的精髓就在于如何取当前最低位1，我们通常使用lowbit(x)，树状数组的优势便在于lowbit极为简短。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br></code></pre></td></tr></table></figure><p> 以二进制数11010为例:11010的补码为00101,加1后为00110,两者相与便是最低位的1 。所以我们只需要进行x&amp;(-x)就可以取出最低位的1了，会了lowbit,我们就可以进行区间查询和单点更新了!!!</p><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><p>每次更新一个点，比如更新a[1]。那么之后n之内的所有根节点，都需要更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        c[i]+=y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>查询即为更新逆操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=<span class="hljs-built_in">lowbit</span>(i))&#123;<br>        ans+=c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么一来，树状数组最基本的两种操作我们便学会了。^_^</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/19/hello-world/"/>
    <url>/2022/04/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
